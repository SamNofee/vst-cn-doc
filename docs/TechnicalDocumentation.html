
  <!DOCTYPE html>
  <head>
    <title>VST中文文档</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./ASSET/shared.css">
    <link rel="stylesheet" href="./ASSET/markdown.css">
    <link rel="stylesheet" href="./ASSET/highlight.min.css">
    <script src="./ASSET/highlight.min.js"></script>
    <script src="./ASSET/shared.js"></script>
    <style>html{font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";}</style>
  </head>
  <body onresize="controlMenu()" onload="init()">
    <template id="tocTreeData" toc-tree-data='[{"name":"什么是VST","id":"za07irgac","url":"WhatIsVST.html","children":[{"name":"用例","url":"WhatIsVST.html#用例","id":"30cjaefkr","children":[]}]},{"name":"VST3的主要优点","id":"tucz9mjoc","url":"MainBenefitsOfVST3.html","children":[]},{"name":"什么是VST3 SDK","id":"1tu1zbc9e","url":"WhatIsTheVST3SDK.html","children":[]},{"name":"快速上手","id":"4j145mywz","url":"GettingStarted.html","children":[{"name":"获取vst3-sdk","url":"GettingStarted.html#获取vst3-sdk","id":"2d98cb93t","children":[]},{"name":"在线文档","url":"GettingStarted.html#在线文档","id":"md7obxwxd","children":[]},{"name":"vst-3-forum","url":"GettingStarted.html#vst-3-forum","id":"05vyxcdug","children":[]},{"name":"vstgui","url":"GettingStarted.html#vstgui","id":"dml1cdsai","children":[]},{"name":"获取源代码","url":"GettingStarted.html#获取源代码","id":"7032zb5e9","children":[]},{"name":"获取用于开发的-ide","url":"GettingStarted.html#获取用于开发的-ide","id":"g2k4lhywx","children":[]},{"name":"package要求","url":"GettingStarted.html#package要求","id":"hzs8ix1g0","children":[]},{"name":"获取cmake","url":"GettingStarted.html#获取cmake","id":"vei6ocxnl","children":[]},{"name":"在-windows-上准备","url":"GettingStarted.html#在-windows-上准备","id":"wul0pi43m","children":[]},{"name":"获取vst3宿主程序","url":"GettingStarted.html#获取vst3宿主程序","id":"p3gaxr5ra","children":[]}]},{"name":"教程","id":"hg70i06hv","url":"Tutorials.html","children":[{"name":"构建sdk里面的示例项目","url":"Tutorials.html#构建sdk里面的示例项目","id":"yds0l7v3e","children":[{"name":"part-1-获取和安装vst3-sdk","url":"Tutorials.html#part-1-获取和安装vst3-sdk","id":"jddzhvmw7","children":[]},{"name":"part-2-构建示例","url":"Tutorials.html#part-2-构建示例","id":"zqwz190w2","children":[]},{"name":"使用cmake-gui构建","url":"Tutorials.html#使用cmake-gui构建","id":"xdv2idquc","children":[]}]},{"name":"使用cmake命令行来构建vst3插件","url":"Tutorials.html#使用cmake命令行来构建vst3插件","id":"a3tfjfuny","children":[{"name":"用于构建-vst-3-插件的-cmake","url":"Tutorials.html#用于构建-vst-3-插件的-cmake","id":"rfsyn308b","children":[]},{"name":"windows命令行","url":"Tutorials.html#windows命令行","id":"4at9yrcl0","children":[]},{"name":"macos命令行","url":"Tutorials.html#macos命令行","id":"ys00jjw71","children":[]},{"name":"在-linux-上使用-qtcreator","url":"Tutorials.html#在-linux-上使用-qtcreator","id":"1lwat2gdu","children":[]},{"name":"cmake-gui-的使用","url":"Tutorials.html#cmake-gui-的使用","id":"91414awh8","children":[]},{"name":"可用的-smtg-cmake-选项","url":"Tutorials.html#可用的-smtg-cmake-选项","id":"ttnxbx4uo","children":[]},{"name":"使用-ide-编译示例","url":"Tutorials.html#使用-ide-编译示例","id":"dsfhu3477","children":[]}]},{"name":"使用项目生成器生成一个新插件","url":"Tutorials.html#使用项目生成器生成一个新插件","id":"uw409jxkl","children":[{"name":"第-1-部分：获取和安装-vst-3-sdk","url":"Tutorials.html#第-1-部分：获取和安装-vst-3-sdk","id":"vi4enue1y","children":[]},{"name":"第-2-部分：使用vst-3-插件项目生成器应用","url":"Tutorials.html#第-2-部分：使用vst-3-插件项目生成器应用","id":"rxdlcdn35","children":[]},{"name":"第-3-部分：编写你的插件","url":"Tutorials.html#第-3-部分：编写你的插件","id":"q9o4w1t5e","children":[{"name":"添加参数-gain","url":"Tutorials.html#添加参数-gain","id":"qacc1r89q","children":[]},{"name":"add-the-process-applying-the-gain","url":"Tutorials.html#add-the-process-applying-the-gain","id":"myddhw0ta","children":[]},{"name":"添加存储恢复状态","url":"Tutorials.html#添加存储恢复状态","id":"sysl9a2w1","children":[]},{"name":"第-4-部分：高级步骤","url":"Tutorials.html#第-4-部分：高级步骤","id":"r5da0wdyp","children":[]},{"name":"添加事件输入","url":"Tutorials.html#添加事件输入","id":"h1w7n4xpk","children":[]},{"name":"添加单声道音频侧链","url":"Tutorials.html#添加单声道音频侧链","id":"visdcg3pl","children":[]}]}]},{"name":"使用vstgui设计一套用户界面","url":"Tutorials.html#使用vstgui设计一套用户界面","id":"oy8ijhqnp","children":[{"name":"第-1-部分：准备","url":"Tutorials.html#第-1-部分：准备","id":"cck2jyprh","children":[]},{"name":"第-2-部分：打开-vstguiwyswyg-编辑器","url":"Tutorials.html#第-2-部分：打开-vstguiwyswyg-编辑器","id":"5dpes1llm","children":[]},{"name":"第-3-部分：参数绑定","url":"Tutorials.html#第-3-部分：参数绑定","id":"gp9ogy9sj","children":[]},{"name":"第-4-部分：创建自定义视图","url":"Tutorials.html#第-4-部分：创建自定义视图","id":"gwb6e4p1r","children":[]},{"name":"第-5-部分：展示例子","url":"Tutorials.html#第-5-部分：展示例子","id":"4ayr4o27l","children":[]}]},{"name":"高级","url":"Tutorials.html#高级","id":"uy1zd9ob5","children":[{"name":"第-1-部分：样本精确参数处理","url":"Tutorials.html#第-1-部分：样本精确参数处理","id":"1stkqcjc5","children":[]},{"name":"第-2-部分：添加-32-位和-64-位音频处理","url":"Tutorials.html#第-2-部分：添加-32-位和-64-位音频处理","id":"v5s1qr9sc","children":[]},{"name":"第-3-部分：线程安全状态更改","url":"Tutorials.html#第-3-部分：线程安全状态更改","id":"ykdhe787n","children":[]}]},{"name":"字符串转换工具","url":"Tutorials.html#字符串转换工具","id":"fm9z8t2gv","children":[{"name":"将-string128-字符串转换为-utf-8-字符串","url":"Tutorials.html#将-string128-字符串转换为-utf-8-字符串","id":"yi7i8suoq","children":[]},{"name":"将-utf-8-字符串转换为-string128-字符串","url":"Tutorials.html#将-utf-8-字符串转换为-string128-字符串","id":"lotckl698","children":[]}]},{"name":"使用helloworld模板创建插件","url":"Tutorials.html#使用helloworld模板创建插件","id":"4v29cimua","children":[{"name":"第-1-部分：获取和安装-vst-3-sdk-1","url":"Tutorials.html#第-1-部分：获取和安装-vst-3-sdk-1","id":"kz3z139x9","children":[]},{"name":"第-2-部分：使用helloworld模板","url":"Tutorials.html#第-2-部分：使用helloworld模板","id":"9ipaj19kg","children":[]}]}]},{"name":"技术文档","id":"3q5byzivn","url":"TechnicalDocumentation.html","children":[{"name":"api文档","url":"TechnicalDocumentation.html#api文档","id":"00h69ncrz","children":[{"name":"基础概念","url":"TechnicalDocumentation.html#基础概念","id":"h47cbuqy5","children":[{"name":"初始化","url":"TechnicalDocumentation.html#初始化","id":"chbilxygf","children":[]},{"name":"从宿主的角度创建和初始化","url":"TechnicalDocumentation.html#从宿主的角度创建和初始化","id":"p4x9ejqon","children":[]},{"name":"扩展","url":"TechnicalDocumentation.html#扩展","id":"fg3t8przb","children":[]},{"name":"持久化","url":"TechnicalDocumentation.html#持久化","id":"zeg55kdp6","children":[]}]},{"name":"处理部分","url":"TechnicalDocumentation.html#处理部分","id":"1p7bftace","children":[]},{"name":"icomponent","url":"TechnicalDocumentation.html#icomponent","id":"z5o6tmnfo","children":[]},{"name":"iaudioprocessor","url":"TechnicalDocumentation.html#iaudioprocessor","id":"7yaeo6oe6","children":[]},{"name":"编辑部分","url":"TechnicalDocumentation.html#编辑部分","id":"f9dphr75o","children":[]},{"name":"vst-3-线程模型","url":"TechnicalDocumentation.html#vst-3-线程模型","id":"whexhk2o4","children":[]},{"name":"组件间通信","url":"TechnicalDocumentation.html#组件间通信","id":"x99g1tou1","children":[{"name":"标准通信","url":"TechnicalDocumentation.html#标准通信","id":"caa9hyur6","children":[]},{"name":"private通信","url":"TechnicalDocumentation.html#private通信","id":"alx7qao1l","children":[]},{"name":"从宿主的角度初始化通信","url":"TechnicalDocumentation.html#从宿主的角度初始化通信","id":"8wsjrmwz1","children":[]}]}]},{"name":"vst模块体系","url":"TechnicalDocumentation.html#vst模块体系","id":"fsqulc7tn","children":[{"name":"宿主将如何加载基于-vst-ma-的插件","url":"TechnicalDocumentation.html#宿主将如何加载基于-vst-ma-的插件","id":"awgdh5z42","children":[]},{"name":"如何从接口派生类","url":"TechnicalDocumentation.html#如何从接口派生类","id":"ou202s38c","children":[]},{"name":"接口版本和继承","url":"TechnicalDocumentation.html#接口版本和继承","id":"ar5d8s0xg","children":[]}]},{"name":"参数和自动化","url":"TechnicalDocumentation.html#参数和自动化","id":"atf4is6dq","children":[{"name":"parameter-styles--step-count","url":"TechnicalDocumentation.html#parameter-styles--step-count","id":"07j9t3m2r","children":[]},{"name":"automation","url":"TechnicalDocumentation.html#automation","id":"qru3g6a13","children":[]},{"name":"sliders--knobs","url":"TechnicalDocumentation.html#sliders--knobs","id":"lb4km4nr9","children":[]},{"name":"buttons--radio-groups--pop-up-menus","url":"TechnicalDocumentation.html#buttons--radio-groups--pop-up-menus","id":"jwd1x5vbo","children":[]},{"name":"text-input","url":"TechnicalDocumentation.html#text-input","id":"jf6jncc5r","children":[]},{"name":"informing-the-host-about-changes","url":"TechnicalDocumentation.html#informing-the-host-about-changes","id":"ajpkvzsa2","children":[]}]},{"name":"vst3单元","url":"TechnicalDocumentation.html#vst3单元","id":"kovbg6aix","children":[{"name":"介绍","url":"TechnicalDocumentation.html#介绍","id":"br34yk4ba","children":[]},{"name":"单元细节","url":"TechnicalDocumentation.html#单元细节","id":"54db5tgyd","children":[]},{"name":"示例","url":"TechnicalDocumentation.html#示例","id":"tk53r8u5i","children":[]}]},{"name":"预设和程序列表","url":"TechnicalDocumentation.html#预设和程序列表","id":"zeb23xf6b","children":[{"name":"简单插件","url":"TechnicalDocumentation.html#简单插件","id":"nvk82eax3","children":[]},{"name":"program-lists","url":"TechnicalDocumentation.html#program-lists","id":"kc5opz4rg","children":[]}]},{"name":"复杂插件多音带乐器","url":"TechnicalDocumentation.html#复杂插件多音带乐器","id":"m6hqbuk9h","children":[{"name":"问题","url":"TechnicalDocumentation.html#问题","id":"7yzvd5682","children":[]},{"name":"the-simple-mode","url":"TechnicalDocumentation.html#the-simple-mode","id":"qn815ldp2","children":[]},{"name":"multi-timbral-program-lists","url":"TechnicalDocumentation.html#multi-timbral-program-lists","id":"5ev5lus7v","children":[]},{"name":"units-and-tracks","url":"TechnicalDocumentation.html#units-and-tracks","id":"3xtma7xqf","children":[]},{"name":"routing","url":"TechnicalDocumentation.html#routing","id":"ahxqcvmbb","children":[]}]},{"name":"vst3工作流程图","url":"TechnicalDocumentation.html#vst3工作流程图","id":"mafsjbcok","children":[{"name":"audio-processor-call-sequence","url":"TechnicalDocumentation.html#audio-processor-call-sequence","id":"rd0t1v7vk","children":[]},{"name":"edit-controller-call-sequence","url":"TechnicalDocumentation.html#edit-controller-call-sequence","id":"50r8z6c5r","children":[]},{"name":"get-latency-call-sequences","url":"TechnicalDocumentation.html#get-latency-call-sequences","id":"rrhlwnu8x","children":[]},{"name":"resize-view-call-sequences","url":"TechnicalDocumentation.html#resize-view-call-sequences","id":"dt2x3l53k","children":[]},{"name":"bus-arrangement-setting-sequences","url":"TechnicalDocumentation.html#bus-arrangement-setting-sequences","id":"vl9p1ai4m","children":[]}]},{"name":"vst-3-位置格式","url":"TechnicalDocumentation.html#vst-3-位置格式","id":"krc424rtq","children":[{"name":"插件的格式结构","url":"TechnicalDocumentation.html#插件的格式结构","id":"phm5o3won","children":[{"name":"macos系统","url":"TechnicalDocumentation.html#macos系统","id":"6evn4mfi3","children":[]},{"name":"windows系统","url":"TechnicalDocumentation.html#windows系统","id":"m8lmch6ql","children":[]},{"name":"linux系统","url":"TechnicalDocumentation.html#linux系统","id":"nzlvaj3es","children":[]},{"name":"合并捆绑","url":"TechnicalDocumentation.html#合并捆绑","id":"hut9fm9d2","children":[]}]}]},{"name":"插件位置","url":"TechnicalDocumentation.html#插件位置","id":"w7pkyt05o","children":[{"name":"介绍-1","url":"TechnicalDocumentation.html#介绍-1","id":"cky8tx0cu","children":[{"name":"on-macos-platform","url":"TechnicalDocumentation.html#on-macos-platform","id":"2tw6nq4gn","children":[]},{"name":"on-windows-platform","url":"TechnicalDocumentation.html#on-windows-platform","id":"o0dy2rwoh","children":[]},{"name":"on-linux-platform","url":"TechnicalDocumentation.html#on-linux-platform","id":"kfa20bqq6","children":[]}]}]},{"name":"预设格式","url":"TechnicalDocumentation.html#预设格式","id":"wnb959psj","children":[]},{"name":"预设位置","url":"TechnicalDocumentation.html#预设位置","id":"scpwqz900","children":[{"name":"介绍-2","url":"TechnicalDocumentation.html#介绍-2","id":"cnge5aua3","children":[{"name":"mac系统","url":"TechnicalDocumentation.html#mac系统","id":"mkfu62f99","children":[]},{"name":"windows-xp2000系统","url":"TechnicalDocumentation.html#windows-xp2000系统","id":"7scz0ce42","children":[]},{"name":"windows-vista7810系统","url":"TechnicalDocumentation.html#windows-vista7810系统","id":"14384zp9u","children":[]},{"name":"linux系统-1","url":"TechnicalDocumentation.html#linux系统-1","id":"y8pc94man","children":[]}]}]},{"name":"快照","url":"TechnicalDocumentation.html#快照","id":"b7fy9ac62","children":[{"name":"介绍-3","url":"TechnicalDocumentation.html#介绍-3","id":"id1dmw99c","children":[]},{"name":"示例-1","url":"TechnicalDocumentation.html#示例-1","id":"40oru8z6v","children":[{"name":"音符音调合成器","url":"TechnicalDocumentation.html#音符音调合成器","id":"bdfj22y2a","children":[]},{"name":"cubase-如何使用快照","url":"TechnicalDocumentation.html#cubase-如何使用快照","id":"4dhrxxel6","children":[]}]}]},{"name":"vst3里的midi","url":"TechnicalDocumentation.html#vst3里的midi","id":"j455gtavv","children":[{"name":"midi-和-vst3-中的相关概念","url":"TechnicalDocumentation.html#midi-和-vst3-中的相关概念","id":"xagjtxffi","children":[]},{"name":"midi-20-per-note-controllers","url":"TechnicalDocumentation.html#midi-20-per-note-controllers","id":"8h1nwv1g7","children":[]},{"name":"与-midi-10-相比，midi-20-增加了分辨率","url":"TechnicalDocumentation.html#与-midi-10-相比，midi-20-增加了分辨率","id":"7gbl53tdc","children":[]}]}]},{"name":"常见问题","id":"0hemg036e","url":"FrequentlyAskedQuestions.html","children":[{"name":"交流","url":"FrequentlyAskedQuestions.html#交流","id":"49or52mdn","children":[]},{"name":"processing","url":"FrequentlyAskedQuestions.html#processing","id":"yyxw53vu2","children":[]},{"name":"gui-editor","url":"FrequentlyAskedQuestions.html#gui-editor","id":"5ym7ryk5l","children":[]},{"name":"compatibility-with-vst-2x-or-vst-1","url":"FrequentlyAskedQuestions.html#compatibility-with-vst-2x-or-vst-1","id":"7shoj7tr3","children":[]},{"name":"persistence","url":"FrequentlyAskedQuestions.html#persistence","id":"9jsg8yfzp","children":[]},{"name":"miscellaneous","url":"FrequentlyAskedQuestions.html#miscellaneous","id":"yz55xu7hd","children":[]},{"name":"license","url":"FrequentlyAskedQuestions.html#license","id":"4yu9yzkso","children":[]}]},{"name":"VST论坛","id":"l94nb9tw3","url":"VST3Forum.html","children":[]},{"name":"其他","id":"y96e2sisg","url":"Miscellaneous.html","children":[{"name":"vst3-sdk里关于版权商标的说明","url":"Miscellaneous.html#vst3-sdk里关于版权商标的说明","id":"g9qpxuufw","children":[]},{"name":"术语表","url":"Miscellaneous.html#术语表","id":"ufewue7oh","children":[]}]}]'></template>
    <div id="menu">
      <div class="menu-box">
        <div id="toc">
        </div>
      </div>
      <div class="menu-bottom">
        <a href="https://github.com/SamNofee/vst-cn-doc">Github</a><a href="/">首页</a>
      </div>
    </div>
    <div id="ball" onclick="controlMenu(true)">
      <div class="ball-icon"></div>
    </div>
    <div class="article-body">
      <article class="markdown-body" style="padding-bottom: 100px;"><h1 id="技术文档">技术文档</h1>
<blockquote>
<p>版本更新历史不在翻译范围内：[版本更新历史链接](<a href="https://developer.steinberg.help/display/VST/Change+History">Change History - VST - Steinberg Developer Help</a>)</p>
</blockquote>
<h2 id="api文档">API文档</h2>
<p><strong>VST 3 API</strong> 是为实时音频处理组件设计的接口集。例如音频效果或音频乐器。
<strong>VST 3</strong> 基于一种称为 <a href="https://developer.steinberg.help/display/VST/VST+Module+Architecture">VST 模块架构</a> (<strong>VST-MA</strong>) 的技术。请参考<a href="https://developer.steinberg.help/display/VST/VST+Module+Architecture">VST-MA 文档</a>了解更多关于插件系统常规工作的细节信息。
API 文档文件<strong>VST 3</strong>位于文件夹“<em>pluginterfaces/vst</em>”。</p>
<h3 id="基础概念">基础概念</h3>
<p>一个<strong>VST 3</strong>音效或乐器基本上由两部分组成：处理部分和编辑控制器部分。
对应的接口有：</p>
<ul>
<li>处理器 : <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IAudioProcessor.html">Steinberg::Vst::IAudioProcessor</a> + <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponent.html">Steinberg::Vst::IComponent</a></li>
<li>控制器 : <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IEditController.html">Steinberg::Vst::IEditController</a></li>
</ul>
<p><img src="IMAGE%5Cbasic_structure.jpg" alt="基本结构"></p>
<p><img src="IMAGE%5Cprocessorcontroller.png" alt="processorcontroller"></p>
<p><strong>VST 3</strong>插件开发可以通过实现两个组件来完全解耦处理器和编辑控制器。分开成这两部分需要一些额外的开发工作。
但是，这种分离使主机能够在不同的上下文与计算机中更好地运行每个组件。另一个好处是，在自动化方面，参数更改可以分离。虽然进行这些更改需要以精确样本传输为代价，但 GUI 可以以很低的频率进行更新，并且可以根据任何延迟补偿或其他的量进行移动。</p>
<p>支持这种分离的插件必须在处理器组件的类中设置 <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/namespaceSteinberg_1_1Vst.html#a626a070dcd2e025250f41b9c3f9817cda3185111648c1599241528f1a7f523396">Steinberg::Vst::kDistributable</a> 标志（<a href="https://steinbergmedia.github.io/vst3_doc/base/structSteinberg_1_1PClassInfo2.html#ab5ab9135185421caad5ad8ae1d758409">Steinberg::PClassInfo2::classFlags</a>）。当然不是每个插件都能做到这一点，例如，如果它非常依赖某一台特定计算机的资源。因此，当未设置此标志时，宿主不得以任何方式分离组件。
虽然不推荐，但可以在一个组件类中同时实现处理部分和控制器部分。宿主在创建 <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IAudioProcessor.html">Steinberg::Vst::IAudioProcessor</a> 后尝试查询 <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IEditController.html">Steinberg::Vst::IEditController</a> 接口，并在成功时将其用作控制器。</p>
<blockquote>
<p>宿主不需要实例化插件的控制器部分来处理它。</p>
<p>插件应准备好被处理，而无需实例化控制器部分。</p>
</blockquote>
<h4 id="初始化">初始化</h4>
<p><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponent.html">Steinberg::Vst::IComponent</a> 和 <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IEditController.html">Steinberg::Vst::IEditController</a> 都派生自 <a href="https://steinbergmedia.github.io/vst3_doc/base/classSteinberg_1_1IPluginBase.html">Steinberg::IPluginBase</a>。这个基本接口的目的是初始化组件并在它被销毁之前终止它。</p>
<p>传递给 <a href="https://steinbergmedia.github.io/vst3_doc/base/classSteinberg_1_1IPluginBase.html#a3c81be4ff2e7bbb541d3527264f26eed">Steinberg::IPluginBase::initialize</a> 的上下文参数应该实现接口 <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IHostApplication.html">Steinberg::Vst::IHostApplication</a>。主机不应在调用初始化之前调用其他函数，<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponent.html#a4618e7358890d549f990010bea4a4137">Steinberg::Vst::IComponent::setIoMode</a> 必须在初始化之前调用。<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponent.html#a8aa65685068ad033af57b1497926b689">Steinberg::Vst::IComponent::getControllerClassId</a>也可以在初始化之前调用（参见<a href="https://developer.steinberg.help/display/VST/VST+3+Workflow+Diagrams">VST3工作流程图</a>）。</p>
<p><strong>插件如何访问IHostApplication？</strong></p>
<pre><code class="language-c++">tresult PLUGIN_API MyPluginProcessor::initialize (FUnknown* context)
{
    FUnknownPtr&lt;IHostApplication&gt; hostApp (hostContext);
    if (hostApp)
    {
        String128 name;
        if (hostApp-&gt;getName (name) == kResultTrue)
        {
            //...
        }
    }
    //..
}
</code></pre>
<h4 id="从宿主的角度创建和初始化">从宿主的角度创建和初始化</h4>
<p>下面是一个宿主实现示例，它使用给定的 classID 创建组件及其关联的控制器：</p>
<pre><code class="language-c++">Vst::IComponent* processorComponent;
Vst::IEditController* editController;
IPluginFactory* factory;
// ...
// factory already initialized (after the library is loaded, see validator for example)
// ...
// create its component part
tresult result = factory-&gt;createInstance (classID, Vst::IComponent::iid, (void**)&amp;processorComponent);
if (processorComponent &amp;&amp; (result == kResultOk))
{
    // initialize the component with our host context (note: initialize called just after creatInstance)
    res = (processorComponent-&gt;initialize (gStandardPluginContext) == kResultOk);
 
    // try to create the controller part from the component
    // for Plug-ins which did not succeed to separate component from controller :-(
    if (processorComponent-&gt;queryInterface (Vst::IEditController::iid, (void**)&amp;editController) != kResultTrue)
    {
        // editController is now created, we have the ownership, which means that we have
        // to release it when not used anymore FUID controllerCID;
 
        // ask for the associated controller class ID (could be called before processorComponent-&gt;initialize ())
        if (processorComponent-&gt;getControllerClassId (controllerCID) == kResultTrue &amp;&amp; controllerCID.isValid ())
        {
            // create its controller part created from the factory
            result = factory-&gt;createInstance (controllerCID, Vst::IEditController::iid, (void**)&amp;editController);
             if (editController &amp;&amp; (result == kResultOk))
            {
                // initialize the component with our context
                res = (editController-&gt;initialize (gStandardPluginContext) == kResultOk);
 
                // now processorComponent and editController are initialized... :-)
            }
        }
    }
}
</code></pre>
<h4 id="扩展">扩展</h4>
<p>这些基本接口组件的功能可以被一些可选接口进行扩展，只有在需要此扩展时才需要实现这些可选接口。</p>
<ul>
<li><p>处理器拓展:</p>
<ul>
<li><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IConnectionPoint.html">Steinberg::Vst::IConnectionPoint</a></li>
<li><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IUnitData.html">Steinberg::Vst::IUnitData</a></li>
<li><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IProgramListData.html">Steinberg::Vst::IProgramListData</a></li>
</ul>
</li>
<li><p>编辑控制器拓展:</p>
<ul>
<li><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IConnectionPoint.html">Steinberg::Vst::IConnectionPoint</a></li>
<li><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IMidiMapping.html">Steinberg::Vst::IMidiMapping</a></li>
<li><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IUnitInfo.html">Steinberg::Vst::IUnitInfo</a></li>
</ul>
</li>
</ul>
<h4 id="持久化">持久化</h4>
<p>宿主在项目文件和预设文件中存储和恢复处理器和控制器的完整状态：</p>
<ul>
<li><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponent.html#a10db03106be8ba89d23859fa6be5d9f6">Steinberg::Vst::IComponent::getState</a> + <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponent.html#a77ac39bcc5c4b15818b1a87de2573805">Steinberg::Vst::IComponent::setState</a>
 保存或恢复DSP模型.</li>
<li><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IEditController.html#a10db03106be8ba89d23859fa6be5d9f6">Steinberg::Vst::IEditController::getState</a> + <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IEditController.html#a77ac39bcc5c4b15818b1a87de2573805">Steinberg::Vst::IEditController::setState</a>
 保存或恢复和处理器无关的GUI设置</li>
<li><strong>Restore:</strong> 当状态恢复时，宿主将状态传递给处理器和控制器(<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IEditController.html#a4c2e1cafd88143fda2767a9c7ba5d48f">Steinberg::Vst::IEditController::setComponentState</a>). 宿主必须始终先将该状态传递给处理器。然后控制器必须将其参数同步到此状态（但不得执行任何 <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponentHandler.html">IComponentHandler</a>的回调）。
 恢复状态后，宿主重新扫描参数（通过询问控制器）以更新其内部表示。</li>
</ul>
<p><img src="IMAGE/persistencestore.png" alt="img"></p>
<p><img src="IMAGE/persistencerestore.png" alt="img"></p>
<p>请参考</p>
<ul>
<li><a href="https://steinbergmedia.github.io/vst3_doc/base/classSteinberg_1_1IBStream.html">Steinberg::IBStream</a></li>
<li><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/group__vstIPlug.html">VST 3 Interfaces to be implemented by the Plug-in</a></li>
<li><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/group__vstIHost.html">VST 3 Interfaces to be implemented by the Host</a></li>
</ul>
<h3 id="处理部分">处理部分</h3>
<p><img src="IMAGE/processorpart.png" alt="img"></p>
<p>处理部分由两个相关接口组成：<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponent.html">Steinberg::Vst::IComponent</a>和<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IAudioProcessor.html">Steinberg::Vst::IAudioProcessor</a>。将两者分开的原因是为了使用基础接口 <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponent.html">Steinberg::Vst::IComponent</a> ，它不仅用于音频插件，还用于其他类型的媒体（例如未来的视频处理）。因此，<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IAudioProcessor.html">Steinberg::Vst::IAudioProcessor</a> 接口表示处理组件的音频部分。让我们仔细看看这些概念。</p>
<h3 id="icomponent">IComponent</h3>
<p><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponent.html">Steinberg::Vst::IComponent</a> 接口让宿主获取有关插件的信息：</p>
<ol>
<li><p><strong>编辑控制器关联</strong>：为了使宿主能够创建与之关联的编辑控制器，处理组件必须提供相应的类ID。宿主使用模块的类工厂来创建控制器组件。参见 <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponent.html#a8aa65685068ad033af57b1497926b689">Steinberg::Vst::IComponent::getControllerClassId</a></p>
</li>
<li><p>宿主可以获取总线配置（<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1BusInfo.html">Steinberg::Vst::BusInfo</a>）。参见 <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponent.html#a41b0e971a0ff153a4eb34274750b0c91">Steinberg::Vst::IComponent::getBusInfo</a></p>
</li>
<li><p>宿主可以请求路由信息（<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1RoutingInfo.html">Steinberg::Vst::RoutingInfo</a>）。</p>
</li>
<li><p>宿主可以激活或停用特定总线，例如 <a href="https://developer.steinberg.help/display/VST/Frequently+Asked+Questions#FrequentlyAskedQuestions-WhatisaSide-chain">side-chain</a>。插件不可处理被停用的总线。参见 <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponent.html#a3ab7d06aaefe03da1fcd1819f1261050">Steinberg::Vst::IComponent::activateBus</a></p>
</li>
<li><p>宿主可以激活或停用插件（开/关按钮）。参见 <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponent.html#a0a840e8077eb74ec429b8007c7b83517">Steinberg::Vst::IComponent::setActive</a></p>
</li>
<li><p>宿主可以存储和恢复插件的状态（预设和项目持久性）。参见 <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponent.html#a10db03106be8ba89d23859fa6be5d9f6">Steinberg::Vst::IComponent::getState</a></p>
</li>
</ol>
<h3 id="iaudioprocessor">IAudioProcessor</h3>
<p><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IAudioProcessor.html">Steinberg::Vst::IAudioProcessor</a> 接口扩展了[Steinberg::Vst::IComponent](<a href="https://steinbergmedia.github.io">https://steinbergmedia.github.io</a> /vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponent.html) ，它提供状态机进行处理：</p>
<ol>
<li><p>设置：必须先配置处理器，然后才能进行处理。且仅当处理器处于非活动状态时才允许配置。</p>
<ul>
<li><p><strong>进程设置</strong>：处理器被告知在活动期间不能更改的参数。 (<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1ProcessSetup.html">Steinberg::Vst::ProcessSetup</a>)。</p>
</li>
<li><p><strong>动态扬声器排列</strong>：宿主可以尝试更改音频总线的通道数。默认情况下，扬声器排列由插件定义。为了调整扬声器上下文，可以使用 [Steinberg::Vst::IAudioProcessor::setBusArrangements](<a href="https://steinbergmedia.github.io/">https://steinbergmedia.github.io/</a> vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IAudioProcessor.html#ad3bc7bac3fd3b194122669be2a1ecc42)</p>
</li>
</ul>
</li>
<li><p>配置处理器时，它必须被激活(<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponent.html#a0a840e8077eb74ec429b8007c7b83517">Steinberg::Vst::IComponent::setActive</a>). 被调用即表示所有配置都已完成。</p>
</li>
<li><p>除此之外，处理器还有一个“处理状态”。在宿主开始执行处理调用之前，它必须通过调用 <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IAudioProcessor.html#af252fd721b195b793f3a5dfffc069401">IAudioProcessor::setProcessing</a>(true)来发出信号。当宿主停止处理时，它必须在最后一次处理调用之后调用 <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IAudioProcessor.html#af252fd721b195b793f3a5dfffc069401">IAudioProcessor::setProcessing</a>(false)。另请参阅：<a href="https://developer.steinberg.help/display/VST/VST+3+Workflow+Diagrams">VST 3 工作流程图</a></p>
</li>
<li><p>Process:Steinberg::Vst::IAudioProcessor::process 是真正的处理函数。处理所需的任何数据都以Steinberg::Vst::ProcessData传递给它。这可一定程度上避免线程同步，因为处理通常在单独的线程中执行。</p>
<ul>
<li><p><strong>Block Size</strong>: 处理是在块中完成的. <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IAudioProcessor.html#aefb5731b94dbc899a4a7e9cd1c96e6a2">Steinberg::Vst::IAudioProcessor::setupProcessing</a>中设置了一个块中要处理的最大样本数。处理块中的实际样本数在调用中传输，并且可以因调用而异，但必须是介于 1 和 <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1ProcessSetup.html#a41cd06a0c942a1b3f283092b893d0de3">maxSamplesPerBlock</a> 之间</p>
<ul>
<li><p><strong>Audio Buffers</strong>: 对于插件定义的任何音频总线，宿主必须提供缓冲区数据，即使是非活动总线。总线使用索引查找，因此忽略不活动的总线会混淆这些索引。但是，实际的数据缓冲区可以为空（参见 <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1AudioBusBuffers.html">Steinberg::Vst::AudioBusBuffers</a>）。</p>
<blockquote>
<p><strong>Note</strong>: <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1AudioBusBuffers.html#abac2239417d88a091cad5b4f917dc49a">channelBuffers32</a>(或<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1AudioBusBuffers.html#a0bbcd9a3e75d01b547097c91f9f659cf">channelBuffers64</a>) 输入和输出的缓冲区指针可以相同也可以不同：在处理函数中必须考虑到这一点（例如，如果输入和输出缓冲区相同，则在处理之前不要重置输出）。对于多个输入或多个输出（在乐器插件的情况下）可以是相同的，所有输出（或输入）可以共享同一个缓冲区！</p>
<p><strong>重要提示</strong>: The host can call <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IAudioProcessor.html#a6b98eb31cf38ba96a28b303c13c64e13">Steinberg::Vst::IAudioProcessor::process</a> without buffers (<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1ProcessData.html#a852a74fc4e461ef086bac048313d2de9">numInputs</a> and <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1ProcessData.html#a1338255f88bad5cf4fb714c71f92b61a">numOutputs</a> of <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1AudioBusBuffers.html">Steinberg::Vst::AudioBusBuffers</a> are zeroed, <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1ProcessData.html#aeb42971a4bd34d7baa27cff8d7e3cf26">numSamples</a> too), in order to flush parameters (from host to plug-in). Parameters can only be flushed when the host needs to send parameter changes and no processing is called.</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>参数和自动化</strong>: 任何参数都通过接口 <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IParameterChanges.html">Steinberg::Vst::IParameterChanges</a> 和 <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IParamValueQueue.html">Steinberg::Vst::IParamValueQueue</a> 在流程调用中传输。 GUI 交互导致的简单参数更改以和自动化完全相同的方式传输 （参见<a href="https://developer.steinberg.help/vst3Automation.html">参数和自动化</a>）。</p>
</li>
<li><p><strong>上下文:</strong> 对于每个处理块，宿主应提供有关其状态的信息。参见 <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1ProcessContext.html">Steinberg::Vst::ProcessContext</a></p>
</li>
<li><p><strong>事件:</strong> <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IEventList.html">Steinberg::Vst::IEventList</a></p>
</li>
</ul>
</li>
</ol>
<p><img src="IMAGE/processorinterfaces.png" alt="img"></p>
<h3 id="编辑部分">编辑部分</h3>
<p><img src="IMAGE/edit%20controller.jpg" alt="img"></p>
<p>编辑控制器负责插件的 GUI 方面。它的标准接口是<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IEditController.html">Steinberg::Vst::IEditController</a>。宿主必须由<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponentHandler.html">Steinberg::Vst::IComponentHandler</a> 编辑控制器提供回调接口。处理程序主要用于宿主和处理器之间的通信。</p>
<ul>
<li><p><strong>GUI：</strong> 控制器可以选择自定义编辑器视图。 <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IEditController.html#a1fa4ed10cc0979e5559045104c998b1a">Steinberg::Vst::IEditController::createView</a> 函数允许宿主传递一个 id字符串。目前只可定义类型“编辑器”（<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/namespaceSteinberg_1_1Vst_1_1ViewType.html#aaa62c4c32f0270a908eb20c7c7124dfc">Steinberg::Vst::ViewType::kEditor</a>），但未来的版本会有其他的更新（例如“设置”）。另见<a href="https://steinbergmedia.github.io/vst3_doc/base/classSteinberg_1_1IPlugView.html">Steinberg::IPlugView</a>。</p>
</li>
<li><p><strong>Parameters:</strong>  控制器负责参数的管理。任何由插件 GUI 中的用户交互引起的参数更改都必须正确报告给<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponentHandler.html">Steinberg::Vst::IComponentHandler</a>。宿主负责将更改传输到处理器。为了使自动化工作得到记录，有必要在列表中调用<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponentHandler.html#a8456ad739430267a12dda11a53fe9223">beginEdit</a>, <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponentHandler.html#a135d4e76355ef0ba0a4162a0546d5f93">performEdit</a>和<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponentHandler.html#ae380206486b11f000cad7c0d9b6e877c">endEdit</a>。或者来自UI-Thread。
 使用新的接口<a href="https://developer.steinberg.help/classSteinberg_1_1Vst_1_1IComponentHandler2.html">IComponentHandler2</a> (从VST 3.1开始)，插件可以分组本应该在同一时间戳被自动化写入的参数，它通过<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponentHandler.html#a8456ad739430267a12dda11a53fe9223">beginEdit</a>/<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponentHandler.html#a135d4e76355ef0ba0a4162a0546d5f93">performEdit</a>/<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponentHandler.html#ae380206486b11f000cad7c0d9b6e877c">endEdit</a>函数(参见 <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponentHandler.html">IComponentHandler</a>) 和<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponentHandler2.html#aba339113df404a6b3c557774d4aa9102">startGroupEdit</a> / <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponentHandler2.html#adbdc10ff7ecd96fa365ad4f98d57b55e">finishGroupEdit</a> 实现
 更多的参数细节参见 <a href="https://developer.steinberg.help/display/VST/Parameters+and+Automation">Parameters</a>.</p>
</li>
<li><p><strong>插件结构:</strong> 如果插件由离散的功能部分组成，编辑控制器应该通过<a href="https://steinbergmedia.github.io/vst3_doc">Steinberg::Vst::IUnitInfo</a>来实现这个结构和实现属于每个部分的参数接口。更多细节可以在<a href="https://developer.steinberg.help/vst3Units.html">VST 3 Units</a>的页面上找到</p>
</li>
</ul>
<p><img src="IMAGE/controllerinterface.png" alt="img"></p>
<h3 id="vst-3-线程模型">VST 3 线程模型</h3>
<p><strong>VST 3</strong> 使用的线程模型非常简单，它要求：</p>
<ul>
<li><p>所有初始化/反初始化都在 UI 线程中完成</p>
</li>
<li><p>插件导出的所有函数都由 UI 线程中的宿主调用，除了：</p>
<ul>
<li>IAudioProcessor→process：可以在音频线程（实时线程）中调用，避免任何内存分配</li>
<li>IAudioProcessor→setProcessing：可以在音频线程（实时线程）中调用，避免任何内存分配</li>
</ul>
</li>
<li><p>宿主导出的所有函数都被UI线程中的插件调用</p>
</li>
</ul>
<p>参见 <a href="https://developer.steinberg.help/display/VST/Audio+Processor+Call+Sequence">Audio Processor Call Sequence</a> 和 <a href="https://developer.steinberg.help/display/VST/Edit+Controller+Call+Sequence">Edit Controller Call Sequence</a></p>
<h3 id="组件间通信">组件间通信</h3>
<p><strong>VST 3</strong> 组件（处理器和控制器）之间需要一种通信方式。宿主的任务主要是处理这个。</p>
<h4 id="标准通信">标准通信</h4>
<p>所有标准数据（如参数更改）都使用下面列出的基本接口在处理器和控制器之间传输。</p>
<ul>
<li><p>创建处理器和控制器后，宿主根据处理器状态设置控制器状态。这与之前的 SDK 有所不同，之前的 SDK 假设在创建后控制器和处理器是同步的。</p>
</li>
<li><p>当主机设置一个新的处理器状态（<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponent.html#a77ac39bcc5c4b15818b1a87de2573805">Steinberg::Vst::IComponent::setState</a>）时，这个状态总是被同时传输到控制器（<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IEditController.html#a4c2e1cafd88143fda2767a9c7ba5d48f">Steinberg::Vst::IEditController::setComponentState</a>）。然后控制器必须同步该状态并调整其参数。</p>
</li>
<li><p>当控制器向宿主传输参数时，宿主通过将新值作为 <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IParameterChanges.html">Steinberg::Vst::IParameterChanges</a> 来同步进程调用。</p>
</li>
<li><p>处理器也可以将传出的参数传输到宿主。 (<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1ProcessData.html#af08c4f7dfd9e456cc98ba0eb325993ae">Steinberg::Vst::ProcessData::outputParameterChanges</a>)。它通过调用 <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IEditController.html#aded549c5b0f342a23dee18cc41ece6b8">Steinberg::Vst::IEditController::setParamNormalized</a> 传输到编辑控制器。</p>
</li>
</ul>
<p><img src="IMAGE/standard_communication.jpg" alt="img"></p>
<h4 id="private通信">Private通信</h4>
<p>宿主不知道的数据可以通过消息的方式传输。通信接口有：</p>
<ul>
<li><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IConnectionPoint.html">Steinberg::Vst::IConnectionPoint</a>: 宿主在处理器和控制器之间建立连接。</li>
<li><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IMessage.html">Steinberg::Vst::IMessage</a>: 表示要发送给对方的消息。</li>
<li><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IAttributeList.html">Steinberg::Vst::IAttributeList</a>: 属于消息的属性列表。</li>
</ul>
<p>请注意，从处理器到控制器的消息不能在进程调用期间发送，因为这样不够快且会破坏实时性。此类任务应在单独的计时器线程中进行处理。</p>
<p><img src="IMAGE/communication.png" alt="img"></p>
<h4 id="从宿主的角度初始化通信">从宿主的角度初始化通信</h4>
<p>这是一个宿主实现的一个示例，其中组件和控制器连接并同步：</p>
<pre><code class="language-c++">//------------------------------------------------------------------------
// the component and the controller parts are previously be created and initialized (see above)
// ...
if (editController)
{
    // set the host handler
    // the host set its handler to the controller
    editController-&gt;setComponentHandler (myHostComponentHandler);
 
    // connect the 2 components
    Vst::IConnectionPoint* iConnectionPointComponent = nullPtr;
    Vst::IConnectionPoint* iConnectionPointController = nullPtr;
 
    processorComponent-&gt;queryInterface (Vst::IConnectionPoint::iid, (void**)&amp;iConnectionPointComponent);
    editController-&gt;queryInterface (Vst::IConnectionPoint::iid, (void**)&amp;iConnectionPointController);
 
    if (iConnectionPointComponent &amp;&amp; iConnectionPointController)
    {
        iConnectionPointComponent-&gt;connect (iConnectionPointController);
        iConnectionPointController-&gt;connect (iConnectionPointComponent);
    }
 
    // synchronize controller to component by using setComponentState
    MemoryStream stream; // defined in &quot;public.sdk/source/common/memorystream.h&quot;
    stream.setByteOrder (kLittleEndian);
    if (processorComponent-&gt;getState (&amp;stream) == kResultTrue)
    {
        stream.rewind ();
        editController-&gt;setComponentState (&amp;stream);
    }
 
    // now processorComponent and editController parts are connected and synchronized...:-)
}
</code></pre>
<blockquote>
<p>处理组件和编辑控制器之间是直接连接的，你不能依赖于连接中的实施细节</p>
</blockquote>
<h2 id="vst模块体系">VST模块体系</h2>
<h3 id="宿主将如何加载基于-vst-ma-的插件">宿主将如何加载基于 VST-MA 的插件</h3>
<p>检查包含的 cpp 文件，如何加载此类组件/插件：</p>
<ul>
<li><em>public.sdk/source/vst/hosting/module.h</em> and</li>
<li><em>for each platform public.sdk/source/vst/hosting/module_win32.cpp,.....</em></li>
</ul>
<p>在下面，你可以看到 Windows 上一个基本的实现，展示如何加载库并获取指向所需导出函数的指针：</p>
<pre><code class="language-c++">HMODULE hModule = LoadLibrary (&quot;SomePlugin.dll&quot;);
if (hModule)
{
    InitModuleProc initProc = (InitModuleProc)GetProcAddress (hModule, &quot;InitDll&quot;);
    if (initProc) // this entry function is optional on Windows, not on MacOS and Linux!
    {
        if (initProc () == false)
        {
            FreeLibrary (module);
            return false;
        }
    }
 
    GetFactoryProc proc = (GetFactoryProc)GetProcAddress (hModule, &quot;GetPluginFactory&quot;);
 
    IPluginFactory* factory = proc ?proc () : 0;
    if (factory)
    {
        for (int32 i = 0; i &lt; factory-&gt;countClasses (); i++)
        {
            PClassInfo ci;
            factory-&gt;getClassInfo (i, &amp;ci);
 
            FUnknown* obj;
            factory-&gt;createInstance (ci.cid, FUnknown::iid, (void**)&amp;obj);
            ...
            obj-&gt;release ();
        }
 
        factory-&gt;release ();
    }
 
    ExitModuleProc exitProc = (ExitModuleProc)GetProcAddress (hModule, &quot;ExitDll&quot;);
    if (exitProc)  // This exit function is optional on Windows, not on MacOS and Linux!
         exitProc ();
 
    FreeLibrary (hModule);
}
</code></pre>
<h3 id="如何从接口派生类">如何从接口派生类</h3>
<pre><code class="language-c++">class CMyClass: public FUnknown
{
public:
    CMyClass ();
    virtual ~CMyClass ();
 
    DECLARE_FUNKNOWN_METHODS  // declares queryInterface, addRef and release
};
 
CMyClass::CMyClass ()
{
    FUNKNOWN_CTOR // init reference counter, increment global object counter
}
 
CMyClass::~CMyClass ()
{
    FUNKNOWN_DTOR // decrement global object counter
}
 
IMPLEMENT_REFCOUNT (CMyClass) // implements reference counting
 
tresult CMyClass::queryInterface (const char* iid, void** obj)
{
    QUERY_INTERFACE (iid, obj, ::FUnknown::iid, CMyClass)
    return kNoInterface;
}
</code></pre>
<p>实现具有多个接口的类是通过多重继承完成的。此外，你必须为 queryInterface 函数中的每个接口提供适当的类型转换。</p>
<pre><code class="language-c++">class CMyMultiClass : public Steinberg::IPluginBase,
                      public Steinberg::IPlugController,
                      public Steinberg::IEditorFactory
{
public:
    DECLARE_FUNKNOWN_METHODS
 
    // declare the methods of all inherited interfaces here...
};
 
IMPLEMENT_REFCOUNT (CMyMultiClass) // implements reference counting
 
tresult CMyMultiClass::queryInterface (const char* iid, void** obj)
{
    QUERY_INTERFACE (iid, obj, Steinberg::FUnknown::iid, IPluginBase)
    QUERY_INTERFACE (iid, obj, Steinberg::IPluginBase::iid, IPluginBase)
    QUERY_INTERFACE (iid, obj, Steinberg::IPlugController::iid, IPlugController)
    QUERY_INTERFACE (iid, obj, Steinberg::IEditorFactory::iid, IEditorFactory)
     *obj = 0;
    return kNoInterface;
}
</code></pre>
<h3 id="接口版本和继承">接口版本和继承</h3>
<p>与 C++ 类不同，<strong>VST-MA</strong> 接口不使用继承来表达对象的特化。通常所有的接口都是从 FUnknown 派生的。这是因为接口在发布后必须<strong>从未</strong>更改。 VST 模块架构接口仅将继承用于版本控制！所有特化都将建模为单独的接口！</p>
<p>C++类的例子:</p>
<pre><code class="language-c++">class Shape
{
public:
    void setPosition (long x, long y);
protected:
    long x;
    long y;
};
class Rect : public Shape
{
public:
    void setDimension (long width, long height);
protected:
    long width;
    long height;
};
</code></pre>
<p><strong>VST-MA</strong>的例子，和上面不一样:</p>
<pre><code class="language-c++">class IShape : public FUnknown
{
public:
    virtual void setPosition (long x, long y) = 0;
};
class IRect : public FUnknown
{
public:
    virtual void setDimension (long width, long height) = 0;
};
</code></pre>
<p>在下一个程序版本中，需要对“Shape”类进行更改，如下所示</p>
<pre><code class="language-c++">class Shape
{
public:
    void setPosition (long x, long y);
    void setColor (Color color);
protected:
    long x;
    long y;
    Color color;
};
</code></pre>
<p><strong>VST-MA</strong> 表示现在通过添加一个继承自 <em>IShape</em> 的新接口来反映对 Shape 的更改，该接口类似于以下代码，而之前的接口定义保持不变：</p>
<pre><code class="language-c++">class IShape2 : public IShape
{
public:
    virtual void setColor (Color color) = 0;
};
</code></pre>
<h2 id="参数和自动化">参数和自动化</h2>
<p>Description of how parameters are defined and used in <strong>VST 3</strong></p>
<p>Parameters</p>
<p>A plug-in requires parameters in order to control its DSP algorithm, for example, a Frequency parameter for a filter. The plug-in can export these parameters in order to make them visible to the host and allow the host to control/change/automate/remote/visualize them. Some parameters can be defined for private use only (not visible to the user) or as read-only, such as parameters associated to VU Meters.</p>
<p><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IEditController.html#ab6ffbb8e3bf6f4829ab1c9c23fe935a1">Steinberg::Vst::IEditController::getParameterCount</a> allows the host to to identify the number of parameters that are exported by the plug-in.
The plug-in must assign a unique 32-bit identifier (ID) to each exported parameter.</p>
<blockquote>
<p>Up to 2^31 parameters can be exported with ID range <strong>[0, 2147483648]</strong> (the range [2147483649, 429496729] is reserved for host application).</p>
</blockquote>
<p>Please note that it is not allowed to change this assignment at any time. In particular, a plug-in must not perform any reconfigurations that lead to a different set of automatable parameters. The only allowed variation is the adding or removing of parameters in a future plug-in version. However, keep in mind that automation data can get lost when parameters are removed.</p>
<p>Usually, the host is unaware of a parameter&#39;s semantics. However, there are a few important exceptions that the controller must announce using the <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1ParameterInfo.html#a8ffba1d4311e48ae488bc118f20d7edb">Steinberg::Vst::ParameterInfo::flags</a>:</p>
<ul>
<li><strong>kCanAutomate:</strong> This means that this parameter can be automated by the host using its automation track. [<strong>SDK 3.0.0</strong>]</li>
<li><strong>kIsBypass:</strong> If the plug-in performs bypass processing itself, it must export the corresponding parameter and flag it with kIsBypass. It is highly recommended that this bypass parameter is provided by the effect plug-in. If the plug-in does not export a bypass parameter, the host can perform bypass processing and the plug-in process call will be discontinued. Only one bypass parameter is allowed. The plug-in should save the state of this bypass parameter like other parameters (when getState and setState are used). If the plug-in does not need a bypass (like Instrument) this flag should be not used. Check this <a href="https://developer.steinberg.help/display/VST/Frequently+Asked+Questions#FrequentlyAskedQuestions-HowdoesAudioProcessingBypasswork?">FAQ</a>in order to understand how bypass processing works. [<strong>SDK 3.0.0</strong>]</li>
<li><strong>kIsReadOnly:</strong> This means that this parameter cannot be changed from outside the plug-in, this requires that kCanAutomate is NOT set. [<strong>SDK 3.0.0</strong>]</li>
<li><strong>kIsWrapAround:</strong> When a UI control created by the host for this parameter attempts to set its value out of the limits, this UI control will make a wrap around (useful for parameters like 360 degree rotation). [<strong>SDK 3.0.2</strong>]</li>
<li><strong>kIsList:</strong> This means that the host will display this parameter as list in a generic editor or automation editing. [<strong>SDK 3.1.0</strong>]</li>
<li><strong>kIsHidden:</strong> This means that this parameter will NOT be displayed and cannot be changed from outside the plug-in. This requires that kCanAutomate is NOT set and kIsReadOnly is set. [<strong>SDK 3.7.0</strong>]</li>
<li><strong>kIsProgramChange:</strong> If the plug-in supports program lists (see <a href="https://developer.steinberg.help/display/VST/VST+3+Units">VST 3 Units</a>, <a href="https://developer.steinberg.help/pages/viewpage.action?pageId=9798267">Program Lists</a>), each &#39;unit&#39; of the plug-in needs to export a program selector parameter. Such a parameter is not allowed to be automated when the affected parameters are flagged as automatable as well. A host can display program parameters at dedicated locations of its GUI. [<strong>SDK 3.0.0</strong>]</li>
</ul>
<p>The controller must support the conversion to a string for any exported parameter. The conversion method <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IEditController.html#aab2f0b853e75361d331b667e7893962e">Steinberg::Vst::IEditController::getParamStringByValue</a>must provide a result for any possible normalized parameter value.</p>
<blockquote>
<p>Parameter values are always transmitted in a normalized floating point (64bit double) representation <strong>[0.0, 1.0]</strong>.</p>
</blockquote>
<p><strong>Representation of parameter values</strong></p>
<p>A plug-in parameter usually has more than one representation. The GUI of a plug-in can display something that appears to be a single parameter, but might control multiple processing parameters at the same time. Or the GUI representation displays a scale-transformed representation of a DSP-Parameter.</p>
<p>Somewhere on the way from the GUI to the DSP algorithm, this transformation has to be performed. The host does not need information about DSP parameters, but it is responsible for reporting parameter changes to the processor. According to this, the processor is the only place where a transformation can happen and all parameters always have to match the GUI representation.</p>
<p>Does this fit into the idea of separating GUI and processing? No problem so far</p>
<ul>
<li>it is a separation of duties, nothing more. The processor component and the controller component have to work on the same internal plug-in model. The controller knows how this model has to be presented in the GUI. The processor knows how the model has to be translated into DSP parameters.
 The <strong>VST 3</strong> interfaces suggest a normalized value representation for a part of this model (the part that is exported as parameters). This means every value has to be inside the range from 0.0 to 1.0.</li>
</ul>
<h3 id="parameter-styles--step-count">Parameter styles / &#39;Step Count&#39;</h3>
<p>Although values are transmitted in a normalized format, the host needs to know some details of the parameter&#39;s displayed GUI representation. When editing automation data, for example, the host must know the nature of a parameter expressed in its &#39;step count&#39; (see <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1ParameterInfo.html#ac1efeff62e4ba9aea101c3327e0b5c4d">Steinberg::Vst::ParameterInfo::stepCount</a>).</p>
<p><strong>Step count semantics</strong> :</p>
<ul>
<li><strong>0</strong> : A <em>continuous</em> parameter. Any normalized value has an exact mapping (0 = there are no steps between the values)</li>
<li><strong>1</strong> : A <em>discrete</em> parameter with 2 states like [on/off] [yes/no] etc. (1 = there is one step between these states)</li>
<li><strong>2</strong> : A <em>discrete</em> parameter with 3 states [0,1,2] or [3,5,7] (2 = there are two steps between these states)</li>
<li><strong>3</strong> : etc...</li>
</ul>
<p><strong>Conversion of normalized values</strong></p>
<p>The controller and the processor have to work with normalized parameter values.</p>
<ul>
<li><p>Step count 0 : Continuous parameters simply need to be mapped accordingly</p>
</li>
<li><p>Step count n : Discrete parameters need a little bit more care</p>
<ul>
<li><p><strong>Discrete Value =&gt; Normalize</strong></p>
</li>
<li><p><strong>Normalize =&gt; Discrete Value (Denormalize)</strong></p>
</li>
</ul>
</li>
</ul>
<p><strong>Example:</strong> Step Count 3</p>
<p><img src="IMAGE/valuerange.jpg" alt="img"></p>
<h3 id="automation">Automation</h3>
<p>A host that supports parameter automation is dependent on a proper cooperation of the component owning these parameters. One intention in the design of the <strong>VST 3</strong> interfaces was to reduce the amount of possible mistakes for an implementation. The separation of processor and controller enforces that all parameter changes have to be handled by the host in a defined way. Additionally, this allows the host to store the changes as automation data. Nevertheless, there are some more things to consider:</p>
<p>No automated parameter must influence another automated parameter!</p>
<p>The prime example for this is the automation of preset changes. A preset change can lead to the change of all &#39;normal&#39; parameters. So if automation data already has been recorded for these parameters and the preset change is recorded as well: who wins? This question cannot be answered and the problem can only be resolved by avoiding it. This is why automation of preset changes is not allowed by default.</p>
<p><strong>Problems</strong></p>
<p>A fix value range from 0.0 to 1.0 simplifies the handling of parameters in some ways, but there are problems:</p>
<ul>
<li><strong>Non-linear scaling</strong>
 If the DSP representation of a value does not scale in a linear way to the exported normalized representation (which can happen when a decibel scale is used, for example), the edit controller must provide a conversion to a plain representation. This allows the host to move automation data (being in GUI representation) and keep the original value relations intact. (<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IEditController.html#a849747dc98909312b4cdbdeea82dbae0">Steinberg::Vst::IEditController::normalizedParamToPlain</a> / <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IEditController.html#ae9706616ae6d938bbf102954f8f2f110">Steinberg::Vst::IEditController::plainParamToNormalized</a>).</li>
<li><strong>Changes in future plug-in versions</strong>
 Take a discrete parameter, for example, that controls an option of three choices. If the host stores normalized values as automation data and a new version of a plug-in invented a fourth choice, the automation data will be invalid now. So either the host has to store denormalized values as automation or it must recalculate the automation data accordingly.</li>
</ul>
<p><strong>Automation Recording</strong></p>
<p>Automation recording is performed by the host. In doing so, it is essential for the host to know the start and the end of a manipulation. Therefore, the plug-in must operate the <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponentHandler.html">Steinberg::Vst::IComponentHandler</a> interface in the following way and in the <strong>UI Thread</strong>!:</p>
<ul>
<li>The begin of a manipulation must be signaled via <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponentHandler.html#a8456ad739430267a12dda11a53fe9223">Steinberg::Vst::IComponentHandler::beginEdit</a></li>
<li>Changes of parameters are reported via <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponentHandler.html#a135d4e76355ef0ba0a4162a0546d5f93">Steinberg::Vst::IComponentHandler::performEdit</a></li>
<li>The end of a manipulation must be signaled via <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponentHandler.html#ae380206486b11f000cad7c0d9b6e877c">Steinberg::Vst::IComponentHandler::endEdit</a></li>
</ul>
<p>The plug-in must stick to the order of these callbacks. Otherwise, automation recording cannot work correctly. However, the implementation can bring up difficulties. Each type of GUI control and the way it is operated along with the nature of the controlled parameter requires specific considerations.
To address the most common cases:</p>
<h3 id="sliders--knobs">Sliders &amp; Knobs</h3>
<p>These kind of controls usually control continuous parameters and they are usually operated with the mouse. This common case is the most simple to handle: On mouse-click-down call beginEdit (followed by performEdit when the control allows a jump), on mouse-drag call performEdit and on mouse-click-up call endEdit.</p>
<p>Trouble starts with the <strong>mouse wheel</strong>: There simply is nothing like a defined start or end when the wheel is operated - each wheel event arrives &#39;out of the blue&#39;. The only way to enable proper automation recording in this case is the usage of a timer.</p>
<ul>
<li><p>A plug-in implementation should call beginEdit when the first wheel event is handled and start a timer (followed by the first call to performEdit). Further wheel events that arrive inside of the timeout interval are reported with performEdit and the timer is restarted. When the timeout period has passed without further events, endEdit should be called and the timer can be removed.</p>
</li>
<li><p>But since it is the host&#39;s task to record automation data, one could argue that it should be the host&#39;s task to take care of the timer in this case. This is the reason for the following exception to the rule:</p>
<ul>
<li>Mouse wheel events can be reported without beginEdit and endEdit to the host. The host must be prepared to receive a performEdit without a previous call of beginEdit for a parameter and handle the timeout itself.</li>
<li></li>
</ul>
</li>
</ul>
<h3 id="buttons--radio-groups--pop-up-menus">Buttons / Radio Groups / Pop-up Menus</h3>
<p>These kind of controls usually control discrete parameters and simply switch the state of something. A proper handling is to call beginEdit, performEdit and endEdit in a row. The affected parameter has to be exported to the host with the correct step count because discrete parameters are handled differently than continuous parameters in regard to automation.</p>
<p>Mouse wheel handling usually is not supported for buttons, but sometimes for pop-up menus. Discrete parameters do not require the usage of a timer in order to be recorded correctly.</p>
<p>So the plug-in should call the 3 functions in a row for each wheel event - again, the other option is to omit beginEdit and endEdit, but in this case, be sure to report the discrete nature of the parameter to the host correctly.</p>
<h3 id="text-input">Text Input</h3>
<p>For reporting the results of a text input value change for a continuous or a discrete parameter, always call beginEdit, performEdit and endEdit in a row.</p>
<p><strong>Automation Playback</strong></p>
<p>In <strong>VST 3</strong>, automation playback is the task of the plug-in and it is the host&#39;s task to provide the automation data. The only way for a parameter change to arrive in the processor is the processing call. Receiving parameter changes from the edit controller and playing back automation data is one and the same thing.</p>
<p>The need to perform all transformations, from the normalized GUI representation to the DSP representation, produces some overhead. Performing sample accurate automation requires even more overhead, because the DSP value must be calculated for each single sample. While this cannot be avoided entirely, it is the choice of the plug-in implementation how much processing time to spend on automation accuracy. The host always transmits value changes in a way that allows a sample accurate reconstruction of the underlying automation curve. The plug-in is responsible for the realization.</p>
<p><img src="IMAGE/automation.jpg" alt="img"></p>
<p>The processor gets the automation data in the processing call by using queue of parameter changes for each parameter having automation data:</p>
<p>a <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IParameterChanges.html">IParameterChanges</a> has some <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IParamValueQueue.html">IParamValueQueue</a>s (for a specific parameter ID) which has some Automation Points.</p>
<blockquote>
<ul>
<li>A parameter (ID) is present only one time in the <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IParameterChanges.html">IParameterChanges</a> list!</li>
<li>Automation Points inside a <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IParamValueQueue.html">IParamValueQueue</a>s are sorted per offset (position inside the audio block)!</li>
</ul>
</blockquote>
<p><strong>GUI playback</strong></p>
<p>The host is responsible for updating the plug-in GUI when automation data is transmitted to the processor. This is realized by frequent calls of <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IEditController.html#aded549c5b0f342a23dee18cc41ece6b8">Steinberg::Vst::IEditController::setParamNormalized</a> in the <strong>UI Thread</strong>.</p>
<p>See also <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IParameterChanges.html">Steinberg::Vst::IParameterChanges</a>, <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IParamValueQueue.html">Steinberg::Vst::IParamValueQueue</a></p>
<h3 id="informing-the-host-about-changes">Informing the host about changes</h3>
<p><strong>Parameter titles, default values or flags have changed</strong></p>
<p>If something happens, user interaction for example, which change the parameter styles (<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1ParameterInfo.html#ae3a5143ca8d0e271dbc259645a4ae645">ParameterFlags</a>) or title or default value of one or multiple parameters, the plug-in must call</p>
<pre><code>`IComponentHandler::restartComponent (kParamTitlesChanged);`
</code></pre>
<p>to inform the host about this change (in the <strong>UI Thread)</strong>. The host rescans the <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1ParameterInfo.html">ParameterInfo</a>s with <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IEditController.html#a0ba78602ecf2f5e8d747d8b01d4cfb6c">getParameterInfo</a>.</p>
<p><strong>Multiple parameter values have changed</strong></p>
<p>As result of a program change for example, the plug-in must call</p>
<pre><code>`IComponentHandler::restartComponent (kParamValuesChanged);`
</code></pre>
<p>to inform the host about this change (in the <strong>UI Thread)</strong>. The host invalidates all caches of parameter values and asks the edit controller for the current values.</p>
<p>If only some values have changed (less than 10)  the plug-in should use the <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponentHandler.html#a135d4e76355ef0ba0a4162a0546d5f93">Steinberg::Vst::IComponentHandler::performEdit</a> interface (Show the right use when automation are used: <a href="https://developer.steinberg.help/display/VST/Parameters+and+Automation#ParametersandAutomation-AutomationRecording">Automation Recording</a>)</p>
<blockquote>
<p>If the plug-in needs to inform the host about changes containing parameter title, default or flags and values (of multiple parameters), it could combine the restartComponent flags:</p>
</blockquote>
<pre><code>`IComponentHandler::restartComponent (kParamValuesChanged|kParamTitlesChanged);`
</code></pre>
<h2 id="vst3单元">VST3单元</h2>
<h3 id="介绍">介绍</h3>
<p>For example, an EQ section can be a unit.
The purposes of units are:</p>
<ul>
<li>Reveal the internal logical structure of the plug-in</li>
<li>Organize parameters by associating them with units</li>
<li>Support program lists</li>
<li>Support handling of Complex Plug-in Structures / Multi-timbral Instruments<ul>
<li>Multiple program lists (associated with a unit)</li>
<li>Access to program list data</li>
<li>Associations of MIDI tracks and units</li>
<li>Synchronization of plug-in GUI and host GUI</li>
</ul>
</li>
</ul>
<h3 id="单元细节">单元细节</h3>
<ul>
<li><p>The plug-in can define any number and any kind of units. The semantics of a unit is not important.</p>
</li>
<li><p>Units are organized in a hierarchical way. Each unit can contain sub-units.</p>
</li>
<li><p>The root unit of this hierarchy is always present (explicit or implicit) and has ID &#39;<strong>0</strong>&#39;. A plug-in that does not define any further units simply consist of unit &#39;0&#39;.</p>
</li>
<li><p>The plug-in has to assign a unique ID to each further unit it defines and must provide a suitable name for it to be shown in the GUI (<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IUnitInfo.html">Steinberg::Vst::UnitInfo</a>).</p>
</li>
<li><p>Each unit can &#39;contain&#39; parameters. All parameters of the plug-in are managed and published by the <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IEditController.html">Steinberg::Vst::IEditController</a>, but each parameter can be associated with a unit. (<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1ParameterInfo.html#a4d2e0574df0f6d36f26fae1ad759a14f">Steinberg::Vst::ParameterInfo::unitId</a>). A host can organize the list of parameters in a tree view reflecting the unit hierarchy as nodes.</p>
</li>
<li><p>Each unit can be associated with a program list. (See <a href="https://developer.steinberg.help/pages/viewpage.action?pageId=9798271">Complex Plug-in Structures / Multi-timbral Instruments</a>)</p>
</li>
<li><p>A unit can be associated with specific busses. There can be any kind of combination, but the VST 3 interfaces only define queries for special situations. (See <a href="file:///C:/Users/YGrabit/Desktop/SDKs/VST3_SDKs/3.7/VST_SDK/VST3_SDK/vst3_doc/vstinterfaces/vst3Multitimbral.html#vst3UnitsTracks">Units and Tracks</a>)</p>
</li>
</ul>
<p><img src="IMAGE/unit.png" alt="img"></p>
<p>Most things of interest in regard to units are GUI related, so the access interface <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IUnitInfo.html">Steinberg::Vst::IUnitInfo</a> needs to be implemented as extension of the edit controller.</p>
<p>See also <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IUnitInfo.html">Steinberg::Vst::IUnitInfo</a>, <a href="https://developer.steinberg.help/pages/viewpage.action?pageId=9798267">Presets &amp; Program Lists</a></p>
<h3 id="示例">示例</h3>
<ul>
<li><p>宿主可以使用带有结构化参数列表的插件示例（来自 <strong>Cubase</strong> 插件集的 MultibandCompressor），在 <strong>Cubase</strong> 中用于选择要自动化的参数：</p>
<p> <img src="IMAGE/unitsexample1.jpg" alt="img"></p>
</li>
<li><p>在 <a href="https://developer.steinberg.help/display/VST">PluginTestHost</a> 的“参数”选项卡中显示结构化参数列表的插件示例（来自 <strong>Cubase</strong> 插件集的 VST Amp Rack）/VST+3+插件+测试+主机）应用：</p>
<p> <img src="IMAGE/unitsexample2.jpg" alt="img"></p>
</li>
<li><p>在 <strong>Cakewalk</strong> 中使用 <strong>HALion Sonic SE</strong> 单元结构进行自动化选择的示例：
 <img src="IMAGE%5CcakewalkUnitExample.png" alt="cakewalkUnitExample"></p>
</li>
</ul>
<h2 id="预设和程序列表">预设和程序列表</h2>
<h3 id="简单插件">简单插件</h3>
<p><img src="IMAGE%5Cpresetsimple.png" alt="presetsimple"></p>
<p>For a simple plug-in, the data of a preset is nothing more than its state. In this case:</p>
<ul>
<li><p>It is the job of the host to manage the preset handling for the plug-in.</p>
</li>
<li><p>The plug-in itself does not need to provide any means in its GUI for loading presets at all and it does not need to define any program lists.</p>
</li>
<li><p>Factory presets must be installed as files at the required location (See <a href="https://developer.steinberg.help/pages/viewpage.action?pageId=9798275#VST3Locations/Format-PresetLocations">Preset Locations</a>).</p>
</li>
</ul>
<p>The host has to provide the GUI for loading and saving preset files. These files contain data that the plug-in has filled into the stream in <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponent.html#a10db03106be8ba89d23859fa6be5d9f6">Steinberg::Vst::IComponent::getState</a>. <strong>VST 3</strong> defines dedicated locations in the OS file system (see <a href="https://developer.steinberg.help/pages/viewpage.action?pageId=9798275#VST3Locations/Format-PresetLocations">Preset Locations</a>), so the host does not need to display a file selector dialog. It knows where to search for preset files of a specific plug-in and where to create them. So it can create a pop-up list for selecting a preset or any other GUI of its choice. After loading a preset, the host is responsible to rescan the parameters values (from the controller part). Therefore, the controller must be sure that it gets the correct parameter states when loading a preset (which is done with <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IEditController.html#a4c2e1cafd88143fda2767a9c7ba5d48f">Steinberg::Vst::IEditController::setComponentState</a>).</p>
<p>See also <a href="https://developer.steinberg.help/display/VST/VST+3+API+Documentation#VST3APIDocumentation-Communicationbetweenthecomponents">Communication between the components</a> and <a href="https://developer.steinberg.help/display/VST/VST+3+API+Documentation#VST3APIDocumentation-Persistence">Persistence</a>.</p>
<h3 id="program-lists">Program Lists</h3>
<p>If a plug-in uses a large pool of programs that require some kind of caching or that need to be preloaded, using preset files may not be a sufficient choice. In this case, the plug-in can define a program list. For this purpose, the edit controller has to be extended by the interface <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IUnitInfo.html">Steinberg::Vst::IUnitInfo</a>.</p>
<ul>
<li><p>If the plug-in defines a program list to be used as pool of factory presets, it must not allow the user to change these presets by the means of parameter editing. Instead, it should load the corresponding data into a kind of working memory and store possible modifications as component state. In addition, the user can be allowed to store the modifications as preset file.</p>
</li>
<li><p>If the plug-in defines a program list to be used as a pool of user presets that are initially in an &#39;empty&#39; state, modifications can be applied to the list items directly. This way of using program lists should only be chosen if programs do require a lot of resources that need to be cached in order to achieve fast program changes (good examples for this are sample-based plug-ins).</p>
</li>
</ul>
<p><img src="IMAGE/single_program_list.jpg" alt="img"></p>
<ul>
<li><p>The plug-in can provide GUI for the selection of programs, but it must enable the host to display the list and the selected program as well. The index of the selected program in the list must be exported as program selection parameter. (<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1ParameterInfo.html#ae3a5143ca8d0e271dbc259645a4ae645a517665185bca1f4f3d77ce0a6468b8e3">Steinberg::Vst::ParameterInfo::kIsProgramChange</a>)</p>
</li>
<li><p>The plug-in can allow the host to read and write the program data of a list item. To support this, the plug-in must implement the <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IProgramListData.html">Steinberg::Vst::IProgramListData</a> interface as an extension of the component part.</p>
</li>
</ul>
<p><strong>Structure of Program Lists</strong></p>
<p>All programs are always transmitted as a flat list to the host. But the plug-in can assign a number of attributes to each program of the list. This enables the host to organize and filter them in a very flexible way. Attribute values are queried via <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IUnitInfo.html#ac40c799f1f52837c311ac153d7a8ead7">Steinberg::Vst::IUnitInfo::getProgramInfo</a>. The possible attribute identifiers are defined in namespace Steinberg::Vst::PresetAttributes. The attribute identifier specifying a program category, for example, is <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/group__presetAttributes.html#ga93cb7a7100ac96cfafceb6216770c42d">Steinberg::Vst::PresetAttributes::kInstrument</a>. Although the name suggests that it should be used for instruments only, it can be used for any kind of audio plug-in. The value for an instrument category of a program is &quot;Piano&quot; for example. But it is possible to specify a subcategory like &quot;Acoustic Piano&quot; as well. In this case, the strings need to be chained like this:
&quot;Piano|Acoustic Piano&quot;. This allows the host to organize presets in a category tree view, for example.</p>
<p><strong>Pitch Names</strong></p>
<p>Pitch names are intended to be used with drum kit programs where the different drum sounds are addressed by note pitches. In order to display the name of the drum instrument assigned to a pitch in a drum editor, for example, the host calls <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IUnitInfo.html#a63c02601259d4e8690f26eefaad53195">Steinberg::Vst::IUnitInfo::hasProgramPitchNames</a> to determine if pitch names are supported and<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IUnitInfo.html#a6126c4506f7981b5e800c6b4daa1e66b">Steinberg::Vst::IUnitInfo::getProgramPitchName</a> to query the pitch name of a single note.</p>
<p>See also <a href="https://developer.steinberg.help/pages/viewpage.action?pageId=9798271">VST 3 Units Multi-timbral Program Lists</a> and check out the <a href="https://developer.steinberg.help/display/VST/VST+3+Plug-ins+Examples">pitchnames VST 3 Plug-in example</a></p>
<h2 id="复杂插件多音带乐器">复杂插件/多音带乐器</h2>
<h3 id="问题">问题</h3>
<p>A simple VST effect plug-in usually does not cause the host too many problems. It has only one audio input and output bus and a defined set of parameters that control aspects of its sound. But a VST plug-in can be a lot more complex than this. When the plug-in implements a multi-timbral musical instrument, the host is confronted with a range of problems regarding the integration of this plug-in in its GUI. To mention a few of them:</p>
<ul>
<li><p>The plug-in can define multiple event input and multiple audio outputs. How can the host know on which output a sound will emerge when a note-event is transmitted to the plug-in?
 -&gt; This may be of interest for the host in order to link a MIDI track to the corresponding audio channel.</p>
</li>
<li><p>The plug-in can define a list of programs that the user can load from the plug-in GUI. In a multi-timbral instrument, a program only affects a certain part of the plug-in (we call this part a &#39;unit&#39;). How can the host know about these parts and about the plug-in defined programs that can be loaded?
 -&gt; This may be of interest for a host in order to provide shortcuts for this functionality in its own GUI.</p>
</li>
</ul>
<p>Since a VST plug-in unlike a hardware MIDI instrument is more than only a black box, a complex plug-in should help its host to provide a more convenient GUI integration than it is possible with hardware instruments. <strong>VST 3</strong> uses the concept of units to describe the internal structure of the plug-in (see <a href="https://developer.steinberg.help/display/VST/VST+3+Units">VST 3 Units</a>) and a multi-timbral instrument is supposed to support the respective interfaces. But the preferred solution in <strong>VST 3</strong> is a reduction of this complexity with the &#39;simple mode&#39;.</p>
<h3 id="the-simple-mode">The Simple Mode</h3>
<p>The &#39;VST 3 simple mode&#39; has the (selfish) background to support the so-called &#39;simple instrument tracks&#39; of Cubase. These tracks combine a MIDI track and VST audio channel (without the need to make any further assignments such as the choice of a MIDI output port or a MIDI channel). This mode is defined as &#39;only one input and only one output&#39;. In &#39;simple mode&#39;, only MIDI channel 0 is used. Therefore, an instrument has to be mono-timbral.</p>
<p>The host will now work with multiple instances of the plug-in rather than using the same instance in a way that it contains multiple internal sections of the same kind. The <strong>VST-MA</strong> component model supports shared resources between multiple instances of a plug-in because usually the same module instance (dll/bundle) is used for each plug-in instance.</p>
<p>Yet, a plug-in has the option to support both the simple and the advanced mode with the same implementation. The host tests the general ability to support the &#39;simple mode&#39; by checking the processor&#39;s class flags (<a href="https://steinbergmedia.github.io/vst3_doc/base/structSteinberg_1_1PClassInfo2.html#ab5ab9135185421caad5ad8ae1d758409">Steinberg::PClassInfo2::classFlags</a>) for the <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/namespaceSteinberg_1_1Vst.html#a626a070dcd2e025250f41b9c3f9817cdabc2edc9bb281cebe9cc6dc00a7cac0ea">Steinberg::Vst::kSimpleModeSupported</a> flag. If the plug-in is to be used in an instrument track (or whenever a host regards it more suitable) the <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponent.html#a4618e7358890d549f990010bea4a4137">Steinberg::Vst::IComponent::setIoMode</a> method is called (before any other call!) to configure the plug-in. A mono-timbral plug-in should set this flag as well and does not need to take into account the <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponent.html#a4618e7358890d549f990010bea4a4137">setIoMode</a>call.</p>
<h3 id="multi-timbral-program-lists">Multi-timbral Program Lists</h3>
<p>For a multi-timbral instrument plug-in, preset handling can be a lot more complex. In this case:</p>
<ul>
<li>The plug-in can define any number of program lists.</li>
<li>Each unit can reference one program list - this reference must not change.</li>
<li>Each unit that uses a program list references one list item.</li>
<li>For each unit referencing a program list, a program selection parameter has to be exported (<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1ParameterInfo.html#ae3a5143ca8d0e271dbc259645a4ae645a517665185bca1f4f3d77ce0a6468b8e3">Steinberg::Vst::ParameterInfo::kIsProgramChange</a>).</li>
<li>The plug-in can provide GUI for the selection of programs, but it must synchronize the corresponding program selection parameter.</li>
<li>A host may want to show the program list of the active unit in the same way as it shows the presets of a simple plug-in (usually in a separate control area at the top or the bottom of the window). The host must be able to display the correct list and the correct program name for the unit that has got the focus in the plug-in GUI.</li>
</ul>
<p>To make this all work correctly, the plug-in must supply a valid implementation of <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IUnitInfo.html">Steinberg::Vst::IUnitInfo</a> and it must operate the callback interface <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IUnitHandler.html">Steinberg::Vst::IUnitHandler</a> accordingly.</p>
<p>Similar to the simple case, the host may want to save and load preset files. The component state of the plug-in is not useful here. A preset of a complex plug-in can be:</p>
<ul>
<li>The state of a plug-in unit
 -&gt; To support this, the plug-in must implement the <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IUnitData.html">Steinberg::Vst::IUnitData</a> interface in its component part.</li>
<li>The contents of an item in the program list
 -&gt; To support this, the plug-in must implement the<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IUnitData.html">Steinberg::Vst::IProgramListData</a> interface in its component part.</li>
</ul>
<p>A plug-in can support unit presets and program list presets.
<img src="IMAGE/program_lists.jpg" alt="img"></p>
<p>See also <a href="https://developer.steinberg.help/pages/viewpage.action?pageId=9798267">Presets &amp; Program Lists</a>, <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IUnitData.html">Steinberg::Vst::IProgramListData</a>, <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IUnitData.html">Steinberg::Vst::IUnitData</a></p>
<h3 id="units-and-tracks">Units and Tracks</h3>
<p>A unit can be associated with busses (or channels of busses). In particular, a unit can have a fixed and unique connection to an input MIDI channel. For a host, it might be useful to know about this connection and which unit can be associated with a specific MIDI track as a result of this. Often, the GUI of a multi-timbral plug-in does not show the settings of all similar units at the same time. Instead, there is some kind of unit selection. The idea is to be able to synchronize the selection of units in a plug-in to the selection of tracks in the host (in both ways).</p>
<p>When a plug-in GUI is organized in the described way, it should support the described behavior by implementing</p>
<ul>
<li><p><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IUnitInfo.html#a718fa905d04d7d559bc89c7ca761413b">Steinberg::Vst::IUnitInfo::getUnitByBus</a> : find out the track - unit relations</p>
</li>
<li><p><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IUnitInfo.html#a6f1b43425ba894764f35b7d492e81c53">Steinberg::Vst::IUnitInfo::getSelectedUnit</a> : let the host know which track to select</p>
</li>
<li><p><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IUnitInfo.html#a2504c2bb3c57742102577f34cb58e257">Steinberg::Vst::IUnitInfo::selectUnit</a> : cause the plug-in to select its unit and by calling</p>
</li>
<li><p><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IUnitHandler.html#ab05a9a8dcca888caeabdb8ed74766bc6">Steinberg::Vst::IUnitHandler::notifyUnitSelection</a> : trigger the host to synchronize its GUI</p>
</li>
</ul>
<h3 id="routing">Routing</h3>
<p>For a host, it may be interesting to know which VSTi channel in the mixer is the output of a specific MIDI track if the plug-in defines multiple audio output busses (represented as VSTi mixer channels in the host).
In general, the host needs to know about any input to output routing of the plug-in. So if an unambiguous relation exists between a plug-in input and an output, the following method should be implemented:</p>
<ul>
<li><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponent.html#aa0ffeccad3c44364a199ce56365a4c12">Steinberg::Vst::IComponent::getRoutingInfo</a> : find out the output of a given input</li>
</ul>
<p><img src="IMAGE/routing.jpg" alt="img"></p>
<h2 id="vst3工作流程图">VST3工作流程图</h2>
<blockquote>
<p>本章较多非图片文件，请到相应链接上看</p>
</blockquote>
<h3 id="audio-processor-call-sequence">Audio Processor Call Sequence</h3>
<p><a href="https://developer.steinberg.help/display/VST/Audio+Processor+Call+Sequence">https://developer.steinberg.help/display/VST/Audio+Processor+Call+Sequence</a></p>
<h3 id="edit-controller-call-sequence">Edit Controller Call Sequence</h3>
<p><a href="https://developer.steinberg.help/display/VST/Edit+Controller+Call+Sequence">https://developer.steinberg.help/display/VST/Edit+Controller+Call+Sequence</a></p>
<h3 id="get-latency-call-sequences">Get Latency Call Sequences</h3>
<p><a href="https://developer.steinberg.help/display/VST/Get+Latency+Call+Sequences">https://developer.steinberg.help/display/VST/Get+Latency+Call+Sequences</a></p>
<h3 id="resize-view-call-sequences">Resize View Call Sequences</h3>
<p><a href="https://developer.steinberg.help/display/VST/Resize+View+Call+Sequences">https://developer.steinberg.help/display/VST/Resize+View+Call+Sequences</a></p>
<h3 id="bus-arrangement-setting-sequences">Bus Arrangement Setting Sequences</h3>
<p><a href="https://developer.steinberg.help/display/VST/Bus+Arrangement+Setting+Sequences">https://developer.steinberg.help/display/VST/Bus+Arrangement+Setting+Sequences</a></p>
<h2 id="vst-3-位置格式">VST 3 位置/格式</h2>
<h3 id="插件的格式结构">插件的格式结构</h3>
<h4 id="macos系统">MacOS系统</h4>
<p>在 macOS 平台上，<strong>VST 3 Plug-in</strong> 是一个标准的 macOS 捆绑包，其文件扩展名为“**.vst3**”，文件夹结构如下：</p>
<table>
<thead>
<tr>
<th align="left">文件夹</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">MyPlugin.vst3/Contents/Resources/</td>
<td align="left">folder contains all additional resource files useful for the plug-in</td>
</tr>
<tr>
<td align="left">MyPlugin.vst3/Contents/MacOS/</td>
<td align="left">folder contains the plug-in’s macOS universal binary (Mach-O)</td>
</tr>
<tr>
<td align="left">MyPlugin.vst3/Contents/Info.plist</td>
<td align="left">the plug-in’s property list</td>
</tr>
<tr>
<td align="left">MyPlugin.vst3/Contents/PkgInfo</td>
<td align="left">specifies the type and creator codes of the bundle (optional)</td>
</tr>
</tbody></table>
<h4 id="windows系统">Windows系统</h4>
<p>在 Windows 平台上，一个 <strong>VST 3 Plug-in</strong> 被组织成一个捆绑包格式（简单文件夹），它的文件扩展名为“**.vst3**”，并具有以下文件夹结构：</p>
<table>
<thead>
<tr>
<th align="left">文件夹</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">MyPlugin.vst3/Contents/Resources/</td>
<td align="left">folder contains all additional resource files useful for the plug-in</td>
</tr>
<tr>
<td align="left">MyPlugin.vst3/Contents/x86-win/MyPlugin.vst3</td>
<td align="left">folder contains the plug-in binary (32 bit dll for the i386 architecture)</td>
</tr>
<tr>
<td align="left">MyPlugin.vst3/Contents/x86_64-win/MyPlugin.vst3</td>
<td align="left">folder contains the plug-in binary (64 bit dll for the x86_64 architecture)</td>
</tr>
<tr>
<td align="left">MyPlugin.vst3/Contents/arm-win/MyPlugin.vst3</td>
<td align="left">Proposal: folder contains the plug-in binary (32 bit dll for the arm architecture)</td>
</tr>
<tr>
<td align="left">MyPlugin.vst3/Contents/arm_64-win/MyPlugin.vst3</td>
<td align="left">Proposal: folder contains the plug-in binary (64 bit dll for the arm64 architecture)</td>
</tr>
<tr>
<td align="left">MyPlugin.vst3/desktop.ini</td>
<td align="left">used to set custom icon in Windows Explorer</td>
</tr>
<tr>
<td align="left">MyPlugin.vst3/Plugin.ico</td>
<td align="left">customized plug-in icon</td>
</tr>
</tbody></table>
<p>在以前的 SDK 中，<strong>VST 3 Plug-in</strong> 被定义为带有 <strong>.vst3</strong> 扩展名的单个 dll 文件。自 VST 3.6.10 起已弃用此功能。</p>
<p>文件 <strong>desktop.ini</strong> 应包含：</p>
<p><strong>desktop.ini</strong></p>
<pre><code>`[.ShellClassInfo]``IconResource=Plugin.ico,``0`
</code></pre>
<p>然后你应该使用此命令行更改它们的属性（<strong>s</strong> 用于系统以确保 Windows 将其用于文件夹/捆绑包，<strong>r</strong> 用于只读，<strong>h</strong> 用于隐藏（可选的））：</p>
<pre><code>`attrib +s +``r` `+``h` `desktop.ini``attrib +``r` `+``h` `Plugin.ico`
</code></pre>
<h4 id="linux系统">Linux系统</h4>
<p>在 Linux 上，<strong>VST 3 Plug-in</strong> 被组织为类似包的包格式，其文件扩展名为“**.vst3**”，它遵循以下文件夹结构：</p>
<table>
<thead>
<tr>
<th align="left">文件夹</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">MyPlugin.vst3/Contents/Resources/</td>
<td align="left">folder contains all additional resource files useful for the plug-in</td>
</tr>
<tr>
<td align="left">MyPlugin.vst3/Contents/i386-linux</td>
<td align="left">folder contains the plug-in binary (32 bit shared library .so for Kernel Architecture i386)</td>
</tr>
<tr>
<td align="left">MyPlugin.vst3/Contents/x86_64-linux</td>
<td align="left">folder contains the plug-in binary (64 bit shared library .so for Kernel Architecture x86_64)</td>
</tr>
<tr>
<td align="left">yPlugin.vst3/Contents/XXX-linux</td>
<td align="left">with XXX the architecture name based on the output of command-line &quot;uname -m&quot; (machine hardware) + &quot;-linux&quot;for example:armv3l-linuxarmv4b-linuxarmv4l-linuxarmv5tel-linuxarmv5tejl-linuxarmv6l-linuxarmv7l-linuxarmv8l-linux</td>
</tr>
</tbody></table>
<h4 id="合并捆绑">合并捆绑</h4>
<p>请注意，所有捆绑包都可以合并为一个，这样就可以拥有一个跨平台的捆绑包/文件夹。</p>
<p>例如：</p>
<pre><code>MyPlugin.vst3/
    |_ Contents/
    |   |__ Resources/
    |   |   |__ Snapshots/
    |   |   |   |__ 84E8DE5F92554F5396FAE4133C935A18_snapshot.png
    |   |   |   |__ 84E8DE5F92554F5396FAE4133C935A18_snapshot_2.0x.png
    |   |   |__ Documentation/
    |   |   |   |__ Manual.pdf
    |   |   |   |__ WhatsNew.pdf
    |   |   |__ Help/
    |   |       |__ helpdoc.xml
    |   |   |__ MyPlugin.srf
    |   |
    |   |__ armv7l-linux/
    |   |   |__ MyPlugin.so
    |   |
    |   |__ i686-linux/
    |   |   |__ MyPlugin.so
    |   |
    |   |__ i386-linux/
    |   |   |__ MyPlugin.so
    |   |
    |   |__ x86_64-linux/
    |   |   |__ MyPlugin.so
    |   |
    |   |__ MacOS/
    |   |   |__ MyPlugin
    |   |
    |   |__ x86-win/
    |   |   |__ MyPlugin.vst3
    |   |
    |   |__ x86_64-win/
    |   |   |__ MyPlugin.vst3
    |   |
    |   |__ Info.plist  (macOS Only)
    |   |__ PkgInfo     (macOS Only)
    |
    |____desktop.ini    (Windows only)
    |___ Plugin.ico     (Windows only)
</code></pre>
<h2 id="插件位置">插件位置</h2>
<h3 id="介绍-1">介绍</h3>
<p><strong>VST 3</strong> 插件应安装在特定的文件夹，下表为不同操作系统指定了这些预定义的位置。</p>
<blockquote>
<p><strong>VST 3</strong> doesn&#39;t require a Plug-in registration like it is used with <strong>DirectX</strong>.</p>
</blockquote>
<blockquote>
<p>Links, Symbolic links or Shortcuts could be used from these predefined folders.</p>
</blockquote>
<p>3 levels of folder location are defined:</p>
<ul>
<li><strong>User</strong>: available only for the current logged user</li>
<li><strong>Global</strong>: available for all users of the system</li>
<li><strong>Application</strong>: available only inside an specific Audio Application (local Plug-ins)</li>
</ul>
<blockquote>
<p>The host should scan at first higher level of priority, first found Plug-in (for a given Processor UID) has to be used.</p>
</blockquote>
<h4 id="on-macos-platform">On macOS platform</h4>
<p>On the macOS platform, the host application expects <strong>VST 3 Plug-ins</strong> to be located in:</p>
<table>
<thead>
<tr>
<th align="left">Priority</th>
<th align="left">Location</th>
<th align="left">Path</th>
<th align="left">Comment</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">User</td>
<td align="left">/Users/$USERNAME/Library/Audio/Plug-ins/VST3/</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">Global</td>
<td align="left">/Library/Audio/Plug-ins/VST3/</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">Global</td>
<td align="left">/Network/Library/Audio/Plug-ins/VST3/</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">Application</td>
<td align="left">$APPFOLDER/Contents/VST3/</td>
<td align="left"></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>Note:</strong> The host recursively scans these folders at startup in this order (User/Global/Application).</p>
</blockquote>
<h4 id="on-windows-platform">On Windows platform</h4>
<p>On the Windows platform, the host application expects <strong>VST 3 Plug-ins</strong> to be located in:</p>
<table>
<thead>
<tr>
<th align="left">Priority</th>
<th align="left">Location</th>
<th align="left">Path</th>
<th align="left">Comment</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">Global</td>
<td align="left">/Program Files/Common Files/VST3/</td>
<td align="left">FOLDERID_ProgramFilesCommonnative bitdepth:32bit Plug-in on 32bit OS,64bit on 64bit OS</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">Global</td>
<td align="left">/Program Files (x86)/Common Files/VST3/</td>
<td align="left">32bit Plug-ins on 64bit Windows</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">Application</td>
<td align="left">$APPFOLDER/VST3/</td>
<td align="left"></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>Note:</strong> The host recursively scans these folders at startup in this order (Global/Application).</p>
</blockquote>
<h4 id="on-linux-platform">On Linux platform</h4>
<p>On the Linux platform, the host application expects <strong>VST 3 Plug-ins</strong> to be located in:</p>
<table>
<thead>
<tr>
<th align="left">Priority</th>
<th align="left">Location</th>
<th align="left">Path</th>
<th align="left">Comment</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">User</td>
<td align="left">$HOME/.vst3/</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">Global</td>
<td align="left">/usr/lib/vst3/</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">Global</td>
<td align="left">/usr/local/lib/vst3/</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">Application</td>
<td align="left">$APPFOLDER/vst3/</td>
<td align="left"></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>Note:</strong> The host recursively scans these folders at startup in this order (User/Global/Application).</p>
</blockquote>
<h2 id="预设格式">预设格式</h2>
<p>文件扩展名必须是**&quot;.vstpreset&quot;<strong>，例如：<em>myBestDefault.vstpreset</em>，指定</strong>VST 3** Preset 文件：
<img src="IMAGE/preset_file_format.jpg" alt="img"></p>
<p>检查 <a href="https://steinbergmedia.github.io/vst3_doc/vstsdk/classSteinberg_1_1Vst_1_1PresetFile.html#a9db1b48345e92320b0dffc446d5e3483">Steinberg::Vst::PresetFile</a> 源代码，它允许读取和写入此类预设。</p>
<h2 id="预设位置">预设位置</h2>
<h3 id="介绍-2">介绍</h3>
<p><strong>VST 3</strong> 位于计算机上的预定义位置，具体取决于操作系统。</p>
<ul>
<li>定义了 3 级预设范围：<ul>
<li><strong>User</strong>: 仅适用于当前登录的用户</li>
<li><strong>Public</strong>: 可供系统的所有用户使用</li>
<li><strong>Apps</strong>: 仅在特定音频应用程序中可用</li>
</ul>
</li>
<li>定义了 4 种类型的预设：<ul>
<li><strong>User</strong>: 用户创建的预设</li>
<li><strong>User_Factory</strong>: 像 <strong>User</strong> 类型，但不直接显示</li>
<li><strong>Shared_Factory</strong>: 插件安装程序安装的出厂预设</li>
<li><strong>App_Factory</strong>: 由音频应用程序安装的预设，仅对该特定音频应用程序可见</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>$COMPANY</strong> 和 <strong>$PLUGIN-NAME</strong> 文件夹名称仅包含文件命名允许的字符（将字符 &quot;<strong>\<em>?/:&lt;&gt;|*</em>&quot; 替换为 &quot;</strong>_** ”）。</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong> 下面定义的每个路径都应按给定的优先级进行扫描，提取预设并将其添加到预设列表中。</p>
</blockquote>
<h4 id="mac系统">Mac系统</h4>
<table>
<thead>
<tr>
<th align="left">Prio</th>
<th align="left">Type</th>
<th align="left">Scope</th>
<th align="left">Writable</th>
<th align="left">Path</th>
<th align="left">Comment</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">User</td>
<td align="left">User</td>
<td align="left">X</td>
<td align="left">Users/$USERNAME/Library/Audio/Presets/$COMPANY/$PLUGIN-NAME/</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">Shared_Factory</td>
<td align="left">Public</td>
<td align="left">-</td>
<td align="left">Library/Audio/Presets/$COMPANY/$PLUGIN-NAME/</td>
<td align="left">Computer shared FactoryROM</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">Shared_Factory</td>
<td align="left">Public</td>
<td align="left">-</td>
<td align="left">Network/Library/Audio/Presets/$COMPANY/$PLUGIN-NAME/</td>
<td align="left">Network shared FactoryROM</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">App_Factory</td>
<td align="left">Apps</td>
<td align="left">-</td>
<td align="left">[$APPFOLDER]/VST3 Presets/$COMPANY/$PLUGIN-NAME/</td>
<td align="left">Host Application (Cubase, ...)</td>
</tr>
</tbody></table>
<h4 id="windows-xp2000系统">Windows XP/2000系统</h4>
<table>
<thead>
<tr>
<th align="left">Prio</th>
<th align="left">Type</th>
<th align="left">Scope</th>
<th align="left">Writable</th>
<th align="left">Path</th>
<th align="left">Comment</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">User</td>
<td align="left">User</td>
<td align="left">X</td>
<td align="left">[my documents]/vst3 presets/$company/$plugin-name/</td>
<td align="left">csidl_personal</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">User_Factory</td>
<td align="left">User</td>
<td align="left">X</td>
<td align="left">[documents and settings/$username/application data]/vst3 presets/$company/$plugin-name/</td>
<td align="left">csidl_appdata</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">Shared_Factory</td>
<td align="left">Public</td>
<td align="left">-</td>
<td align="left">[documents and settings/$allusers/application data]/vst3 presets/$company/$plugin-name/</td>
<td align="left">csidl_common_appdata</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">App_Factory</td>
<td align="left">Apps</td>
<td align="left">-</td>
<td align="left">[$APPFOLDER]/VST3 Presets/$COMPANY/$PLUGIN-NAME/</td>
<td align="left">Host Application (Cubase, ...)</td>
</tr>
</tbody></table>
<h4 id="windows-vista7810系统">Windows Vista/7/8/10系统</h4>
<table>
<thead>
<tr>
<th align="left">Prio</th>
<th align="left">Type</th>
<th align="left">Scope</th>
<th align="left">Writable</th>
<th align="left">Path</th>
<th align="left">Comment</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">User</td>
<td align="left">User</td>
<td align="left">X</td>
<td align="left">[Users/$USERNAME/Documents]/VST3 Presets/$COMPANY/$PLUGIN-NAME/</td>
<td align="left">FOLDERID_Documents</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">User_Factory</td>
<td align="left">User</td>
<td align="left">X</td>
<td align="left">[Users/$USERNAME/AppData/Roaming]/VST3 Presets/$COMPANY/$PLUGIN-NAME/</td>
<td align="left">FOLDERID_RoamingAppData</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">Shared_Factory</td>
<td align="left">Public</td>
<td align="left">-</td>
<td align="left">[ProgramData]/VST3 Presets/$COMPANY/$PLUGIN-NAME/</td>
<td align="left">FOLDERID_ProgramData</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">App_Factory</td>
<td align="left">Apps</td>
<td align="left">-</td>
<td align="left">[$APPFOLDER]/VST3 Presets/$COMPANY/$PLUGIN-NAME/</td>
<td align="left">Host Application (Cubase, ...)</td>
</tr>
</tbody></table>
<h4 id="linux系统-1">Linux系统</h4>
<table>
<thead>
<tr>
<th align="left">Prio</th>
<th align="left">Type</th>
<th align="left">Scope</th>
<th align="left">Writable</th>
<th align="left">Path</th>
<th align="left">Comment</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">User</td>
<td align="left">User</td>
<td align="left">X</td>
<td align="left">$HOME/.vst3/presets/$COMPANY/$PLUGIN-NAME/</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">Shared_Factory</td>
<td align="left">Public</td>
<td align="left">-</td>
<td align="left">/usr/share/vst3/presets/$COMPANY/$PLUGIN-NAME/</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">Shared_Factory</td>
<td align="left">Public</td>
<td align="left">-</td>
<td align="left">/usr/local/share/vst3/presets/$COMPANY/$PLUGIN-NAME/</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">App_Factory</td>
<td align="left">Apps</td>
<td align="left">-</td>
<td align="left">[$APPFOLDER]/vst3/presets/$COMPANY/$PLUGIN-NAME/</td>
<td align="left">Host Application</td>
</tr>
</tbody></table>
<h2 id="快照">快照</h2>
<h3 id="介绍-3">介绍</h3>
<p>从 VST 3.6.10 开始，<strong>VST 3</strong> 包含 <strong>VST 3</strong> 宿主的预渲染快照图像，作为插件 UI 的可视化预览。此快照必须具有预定义的格式和文件名，以便主机能够识别它。</p>
<ul>
<li>图片格式必须是PNG</li>
<li>图像需要位于文件夹 <strong>Resources/Snapshots/</strong> 中的捆绑目录内</li>
<li>文件名必须以 84E8DE5F92554F5396FAE4133C935A18 形式打印的音频处理器的唯一 ID 开头，后跟字符串 _snapshot，可选地后跟 HiDPI 比例因子 _2.0x，并以文件扩展名 .png 结尾。<ul>
<li>例如，again 的快照必须命名为：<ul>
<li><strong>84E8DE5F92554F5396FAE4133C935A18_snapshot.png</strong></li>
<li><strong>84E8DE5F92554F5396FAE4133C935A18_snapshot_2.0x.png</strong> for the 2x scaled HiDPI variant.</li>
</ul>
</li>
<li>如果省略 HiDPI 比例，则使用比例1。</li>
</ul>
</li>
</ul>
<h3 id="示例-1">示例</h3>
<h4 id="音符音调合成器">音符音调合成器</h4>
<p><img src="IMAGE/6EE65CD1B83A4AF480AA7929AEA6B8A0_snapshot_2.0x.png" alt="img"></p>
<h4 id="cubase-如何使用快照">Cubase 如何使用快照</h4>
<p><img src="IMAGE/snapshotCubase.png" alt="img"></p>
<p>在媒体选项卡下的右侧区域中，用户可以使用快照选择 FX 和乐器。</p>
<h2 id="vst3里的midi">VST3里的MIDI</h2>
<p>与 <strong>VST 2</strong> 不同，<strong>MIDI</strong> 不包含在 <strong>VST 3</strong> 中。但是 <strong>VST 3</strong> 提供了可以使用 <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1Event.html">Event</a> 与 MIDI 相互转换的方法：</p>
<p><img src="IMAGE/event.png" alt="img"></p>
<h3 id="midi-和-vst3-中的相关概念">MIDI 和 VST3 中的相关概念</h3>
<p><strong>MIDI 1.0</strong> 到 <strong>VST 3</strong> 中的概念关系</p>
<table>
<thead>
<tr>
<th align="left">MIDI 1.0</th>
<th align="left">VST 3</th>
<th align="left">Defined in</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Port</td>
<td align="left">Bus of<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/group__vstBus.html#ga576e5da9bdc49812cf65f803bb303ad5">Steinberg::Vst::MediaType</a>, <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/group__vstBus.html#gga576e5da9bdc49812cf65f803bb303ad5ae6a97de99980aeac9312e818af337d6f">Steinberg::Vst::MediaTypes::kEvent</a></td>
<td align="left"><em>ivstcomponent.h</em></td>
</tr>
<tr>
<td align="left">Channel</td>
<td align="left">Channel of a Bus, <a href="https://developer.steinberg.help/display/VST/VST+3+Units">Unit by Bus</a> and Channel</td>
<td align="left"><em>ivstcomponent.h, ivstunits.h</em></td>
</tr>
<tr>
<td align="left">Note-On</td>
<td align="left"><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1NoteOnEvent.html">Steinberg::Vst::NoteOnEvent</a></td>
<td align="left"><em>ivstevents.h</em></td>
</tr>
<tr>
<td align="left">Note-Off</td>
<td align="left"><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1NoteOffEvent.html">Steinberg::Vst::NoteOffEvent</a></td>
<td align="left"><em>ivstevents.h</em></td>
</tr>
<tr>
<td align="left">Poly Key Pressure</td>
<td align="left"><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1PolyPressureEvent.html">Steinberg::Vst::PolyPressureEvent</a></td>
<td align="left"><em>ivstevents.h</em></td>
</tr>
<tr>
<td align="left">Control Change</td>
<td align="left"><a href="https://developer.steinberg.help/display/VST/Parameters+and+Automation">Parameter</a>, <a href="https://developer.steinberg.help/display/VST/%5B3.0.1%5D+Parameter+MIDI+Mapping+Support">IMidiMapping</a></td>
<td align="left"><em>ivstcomponent.h, ivstmidicontrollers.h</em></td>
</tr>
<tr>
<td align="left">Channel Pressure</td>
<td align="left"><a href="https://developer.steinberg.help/display/VST/Parameters+and+Automation">Parameter</a>, <a href="https://developer.steinberg.help/display/VST/%5B3.0.1%5D+Parameter+MIDI+Mapping+Support">IMidiMapping</a></td>
<td align="left"><em>ivstcomponent.h, ivstmidicontrollers.h</em></td>
</tr>
<tr>
<td align="left">Pitch Bend</td>
<td align="left"><a href="https://developer.steinberg.help/display/VST/Parameters+and+Automation">Parameter</a>, <a href="https://developer.steinberg.help/display/VST/%5B3.0.1%5D+Parameter+MIDI+Mapping+Support">IMidiMapping</a></td>
<td align="left"><em>ivstcomponent.h, ivstmidicontrollers.h</em></td>
</tr>
<tr>
<td align="left">Program Change</td>
<td align="left"><a href="https://developer.steinberg.help/display/VST/Parameters+and+Automation">Parameter</a>, <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1ParameterInfo.html#ae3a5143ca8d0e271dbc259645a4ae645a517665185bca1f4f3d77ce0a6468b8e3">kIsProgramChange</a>, <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1ProgramListInfo.html">Steinberg::Vst::ProgramListInfo</a></td>
<td align="left"><em>ivstcomponent.h, ivstunits.h</em></td>
</tr>
<tr>
<td align="left">MPE (MIDI Polyphonic Expression)</td>
<td align="left"><a href="https://developer.steinberg.help/display/VST/%5B3.5.0%5D+Note+Expression+Support">NoteExpression</a>, <a href="https://developer.steinberg.help/display/VST/%5B3.6.11%5D+NoteExpression+Physical+UI+Mapping+Support">PhysicalUI</a></td>
<td align="left"><em>ivstnoteexpression.h, ivstphysicalui.h</em></td>
</tr>
<tr>
<td align="left">System Exclusive</td>
<td align="left"><a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1DataEvent.html">Steinberg::Vst::DataEvent</a>of Type <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1DataEvent.html#afb6eb4f28419b652027fad41104a6d22ab06d86440be6a85eccce4df100ce8e79">Steinberg::Vst::DataEvent::kMidiSysEx</a></td>
<td align="left"><em>ivstevents.h</em></td>
</tr>
</tbody></table>
<p>MIDI 2.0 (<a href="https://www.midi.org/">https://www.midi.org/</a>) 中引入的概念与 <strong>VST 3</strong> 的其他关系</p>
<table>
<thead>
<tr>
<th align="left">MIDI 2.0</th>
<th align="left">VST 3</th>
<th align="left">Defined in / Comments</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Group (of Channels)</td>
<td align="left">Bus of <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/group__vstBus.html#ga576e5da9bdc49812cf65f803bb303ad5">Steinberg::Vst::MediaType</a>, <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/group__vstBus.html#gga576e5da9bdc49812cf65f803bb303ad5ae6a97de99980aeac9312e818af337d6f">Steinberg::Vst::MediaTypes::kEvent</a></td>
<td align="left"><em>ivstcomponent.h</em></td>
</tr>
<tr>
<td align="left">Registered Per-Note Controller</td>
<td align="left"><a href="https://developer.steinberg.help/display/VST/%5B3.5.0%5D+Note+Expression+Support">NoteExpression</a>, <a href="https://developer.steinberg.help/display/VST/%5B3.6.11%5D+NoteExpression+Physical+UI+Mapping+Support">PhysicalUI</a></td>
<td align="left"><em>ivstnoteexpression.h, ivstphysicalui.h</em></td>
</tr>
<tr>
<td align="left">Assignable Per-Note Controller</td>
<td align="left"><a href="https://developer.steinberg.help/display/VST/%5B3.5.0%5D+Note+Expression+Support">NoteExpression</a></td>
<td align="left"><em>ivstnoteexpression.h</em></td>
</tr>
<tr>
<td align="left">System Exclusive 8-Bit</td>
<td align="left">indirect support</td>
<td align="left">The host can translate to 7-Bit, <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1DataEvent.html">Steinberg::Vst::DataEvent</a>of Type <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/structSteinberg_1_1Vst_1_1DataEvent.html#afb6eb4f28419b652027fad41104a6d22ab06d86440be6a85eccce4df100ce8e79">Steinberg::Vst::DataEvent::kMidiSysEx</a></td>
</tr>
<tr>
<td align="left">Registered Controller</td>
<td align="left">not supported</td>
<td align="left">The host can do detailed tuning via <a href="https://developer.steinberg.help/display/VST/%5B3.5.0%5D+Note+Expression+Support">NoteExpression</a></td>
</tr>
<tr>
<td align="left">Assignable Controller</td>
<td align="left">not supported</td>
<td align="left">The host should offer mapping to parameters</td>
</tr>
<tr>
<td align="left">Relative Registered Controller</td>
<td align="left">not supported</td>
<td align="left">The host is free to translate this to parameters</td>
</tr>
<tr>
<td align="left">Relative Assignable Controller</td>
<td align="left">not supported</td>
<td align="left">The host is free to translate this to parameters</td>
</tr>
<tr>
<td align="left">Per-Note Pitch Bend</td>
<td align="left">not supported</td>
<td align="left">The host can do detailed tuning via <a href="https://developer.steinberg.help/display/VST/%5B3.5.0%5D+Note+Expression+Support">NoteExpression</a></td>
</tr>
<tr>
<td align="left">Mixed Data Set</td>
<td align="left">not supported</td>
<td align="left">not supported</td>
</tr>
</tbody></table>
<h3 id="midi-20-per-note-controllers">MIDI 2.0 Per-Note Controllers</h3>
<p><strong>MIDI 2.0</strong> Per-Note Controllers 和 <a href="https://developer.steinberg.help/display/VST/%5B3.5.0%5D+Note+Expression"><strong>VST 3</strong> NoteExpression</a> 之间有许多细微差别+支持。好消息是插件开发人员不必为此做任何事情。宿主则有责任将 MIDI 2.0 转换成 <strong>VST 3</strong>。</p>
<h3 id="与-midi-10-相比，midi-20-增加了分辨率">与 MIDI 1.0 相比，MIDI 2.0 增加了分辨率</h3>
<p><strong>MIDI 2.0</strong> 与<strong>MIDI 1.0</strong> 相比，在许多重要值（例如力度、压力和控制器）的分辨率上实现了显着提高。尽管如此，<strong>VST 3</strong> 仍然具有比 <strong>MIDI 2.0</strong> 更高的分辨率。支持 <strong>VST 3</strong> 的插件和主机应该积极利用这些功能。</p>
<p>下面是这三者的比较</p>
<table>
<thead>
<tr>
<th align="left">Value</th>
<th align="left">MIDI 1.0</th>
<th align="left">MIDI 2.0</th>
<th align="left">VST 3</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Velocity (On &amp; Off)</td>
<td align="left">7 Bit integer</td>
<td align="left">16 Bit integer</td>
<td align="left">32 Bit float</td>
</tr>
<tr>
<td align="left">Poly Pressure</td>
<td align="left">7 Bit integer</td>
<td align="left">32 Bit integer</td>
<td align="left">32 Bit float</td>
</tr>
<tr>
<td align="left">Channel Pressure / Parameters</td>
<td align="left">7 Bit integer</td>
<td align="left">32 Bit integer</td>
<td align="left">64 Bit float</td>
</tr>
<tr>
<td align="left">Controllers / Parameters</td>
<td align="left">7-14 Bit integer</td>
<td align="left">32 Bit integer</td>
<td align="left">64 Bit float</td>
</tr>
<tr>
<td align="left">Pitch Bend / Parameters</td>
<td align="left">14 Bit integer</td>
<td align="left">32 Bit integer</td>
<td align="left">64 Bit float</td>
</tr>
<tr>
<td align="left">Note Attribute Tuning</td>
<td align="left">not available</td>
<td align="left">16 Bit fixed point (7.9)</td>
<td align="left">32 Bit float</td>
</tr>
<tr>
<td align="left">Per-Note Controllers / <a href="https://developer.steinberg.help/display/VST/%5B3.5.0%5D+Note+Expression+Support">NoteExpression</a></td>
<td align="left">not available</td>
<td align="left">32 Bit integer</td>
<td align="left">64 Bit float</td>
</tr>
</tbody></table>
</article>
    </div>
  </body>
  